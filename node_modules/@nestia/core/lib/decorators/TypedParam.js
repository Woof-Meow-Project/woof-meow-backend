"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypedParam = void 0;
var common_1 = require("@nestjs/common");
var typia_1 = __importDefault(require("typia"));
var NoTransformConfigureError_1 = require("./internal/NoTransformConfigureError");
/**
 * Type safe URL parameter decorator.
 *
 * `TypedParam` is a decorator function getting specific typed parameter from the
 * HTTP request URL. It's almost same with the {@link nest.Param}, but `TypedParam`
 * automatically casts parameter value to be following its type, and validates it.
 *
 * ```typescript
 * import { tags } from "typia";
 *
 * \@TypedRoute.Get("shopping/sales/:id/:no/:paused")
 * public async pause
 *     (
 *         \@TypedParam("id", "uuid"), id: string & tags.Format<"uuid">,
 *         \@TypedParam("no") id: number & tags.Type<"uint32">
 *         \@TypedParam("paused") paused: boolean | null
 *     ): Promise<void>;
 * ```
 *
 * @param name URL Parameter name
 * @returns Parameter decorator
 *
 * @author Jeongho Nam - https://github.com/samchon
 */
function TypedParam(name, assert) {
    if (assert === undefined)
        throw (0, NoTransformConfigureError_1.NoTransformConfigureError)("TypedParam");
    return (0, common_1.createParamDecorator)(function TypedParam(_a, context) {
        var request = context
            .switchToHttp()
            .getRequest();
        var str = request.params[name];
        try {
            return assert(str);
        }
        catch (exp) {
            if ((function (input) {
                var $io0 = function (input) { return "string" === typeof input.method && (undefined === input.path || "string" === typeof input.path) && "string" === typeof input.expected && true && "string" === typeof input.name && "string" === typeof input.message && (undefined === input.stack || "string" === typeof input.stack); };
                return "object" === typeof input && null !== input && $io0(input);
            })(exp))
                throw new common_1.BadRequestException({
                    path: exp.path,
                    reason: exp.message,
                    expected: exp.expected,
                    value: exp.value,
                    message: "Invalid URL parameter value on \"".concat(name, "\"."),
                });
            throw exp;
        }
    })(name);
}
exports.TypedParam = TypedParam;
Object.assign(TypedParam, typia_1.default.http.parameter);
//# sourceMappingURL=TypedParam.js.map