"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypedQuery = void 0;
var common_1 = require("@nestjs/common");
var rxjs_1 = require("rxjs");
var typia_1 = __importDefault(require("typia"));
var get_path_and_querify_1 = require("./internal/get_path_and_querify");
var route_error_1 = require("./internal/route_error");
var validate_request_query_1 = require("./internal/validate_request_query");
/**
 * Type safe URL query decorator.
 *
 * `TypedQuery` is a decorator function that can parse URL query string. It is almost
 * same with {@link nest.Query}, but it can automatically cast property type following
 * its DTO definition. Also, `TypedQuery` performs type validation.
 *
 * For reference, target type `T` must follw such restriction. Also, if actual URL
 * query parameter values are different with their promised type `T`,
 * `BadRequestException` error (status code: 400) would be thrown.
 *
 * 1. Type `T` must be an object type
 * 2. Do not allow dynamic property
 * 3. Only `boolean`, `bigint`, `number`, `string` or their array types are allowed
 * 4. By the way, union type never be not allowed
 *
 * @returns Parameter decorator
 * @author Jeongho Nam - https://github.com/samchon
 */
function TypedQuery(validator) {
    var checker = (0, validate_request_query_1.validate_request_query)(validator);
    return (0, common_1.createParamDecorator)(function TypedQuery(_unknown, context) {
        var request = context
            .switchToHttp()
            .getRequest();
        var params = new URLSearchParams(tail(request.url));
        var output = checker(params);
        if (output instanceof Error)
            throw output;
        return output;
    })();
}
exports.TypedQuery = TypedQuery;
(function (TypedQuery) {
    var e_1, _a, e_2, _b, e_3, _c;
    function Body(validator) {
        var checker = (0, validate_request_query_1.validate_request_query)(validator);
        return (0, common_1.createParamDecorator)(function TypedQueryBody(_unknown, context) {
            var request = context
                .switchToHttp()
                .getRequest();
            if (isApplicationQuery(request.headers["content-type"]) === false)
                throw new common_1.BadRequestException("Request body type is not \"application/x-www-form-urlencoded\".");
            var params = request.body instanceof URLSearchParams
                ? request.body
                : new FakeURLSearchParams(request.body);
            var output = checker(params);
            if (output instanceof Error)
                throw output;
            return output;
        })();
    }
    TypedQuery.Body = Body;
    Object.assign(Body, typia_1.default.http.assertQuery);
    Object.assign(Body, typia_1.default.http.isQuery);
    Object.assign(Body, typia_1.default.http.validateQuery);
    /**
     * Router decorator function for the GET method.
     *
     * @param path Path of the HTTP request
     * @returns Method decorator
     */
    TypedQuery.Get = Generator("Get");
    /**
     * Router decorator function for the POST method.
     *
     * @param path Path of the HTTP request
     * @returns Method decorator
     */
    TypedQuery.Post = Generator("Post");
    /**
     * Router decorator function for the PATH method.
     *
     * @param path Path of the HTTP request
     * @returns Method decorator
     */
    TypedQuery.Patch = Generator("Patch");
    /**
     * Router decorator function for the PUT method.
     *
     * @param path Path of the HTTP request
     * @returns Method decorator
     */
    TypedQuery.Put = Generator("Put");
    /**
     * Router decorator function for the DELETE method.
     *
     * @param path Path of the HTTP request
     * @returns Method decorator
     */
    TypedQuery.Delete = Generator("Delete");
    /**
     * @internal
     */
    function Generator(method) {
        function route() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _a = __read((0, get_path_and_querify_1.get_path_and_querify)("TypedQuery.".concat(method)).apply(void 0, __spreadArray([], __read(args), false)), 2), path = _a[0], stringify = _a[1];
            return (0, common_1.applyDecorators)(ROUTERS[method](path), (0, common_1.UseInterceptors)(new TypedQueryRouteInterceptor(stringify)));
        }
        return route;
    }
    try {
        for (var _d = __values([typia_1.default.assert, typia_1.default.is, typia_1.default.validate]), _e = _d.next(); !_e.done; _e = _d.next()) {
            var method = _e.value;
            try {
                for (var _f = (e_2 = void 0, __values(Object.entries(method))), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var _h = __read(_g.value, 2), key = _h[0], value = _h[1];
                    try {
                        for (var _j = (e_3 = void 0, __values([
                            TypedQuery.Get,
                            TypedQuery.Delete,
                            TypedQuery.Post,
                            TypedQuery.Put,
                            TypedQuery.Patch,
                        ])), _k = _j.next(); !_k.done; _k = _j.next()) {
                            var deco = _k.value;
                            deco[key] = value;
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
        }
        finally { if (e_1) throw e_1.error; }
    }
})(TypedQuery || (exports.TypedQuery = TypedQuery = {}));
Object.assign(TypedQuery, typia_1.default.http.assertQuery);
Object.assign(TypedQuery, typia_1.default.http.isQuery);
Object.assign(TypedQuery, typia_1.default.http.validateQuery);
/**
 * @internal
 */
function tail(url) {
    var index = url.indexOf("?");
    return index === -1 ? "" : url.substring(index + 1);
}
/**
 * @internal
 */
function isApplicationQuery(text) {
    return (text !== undefined &&
        text
            .split(";")
            .map(function (str) { return str.trim(); })
            .some(function (str) { return str === "application/x-www-form-urlencoded"; }));
}
/**
 * @internal
 */
var FakeURLSearchParams = /** @class */ (function () {
    function FakeURLSearchParams(target) {
        this.target = target;
    }
    FakeURLSearchParams.prototype.has = function (key) {
        return this.target[key] !== undefined;
    };
    FakeURLSearchParams.prototype.get = function (key) {
        var _a;
        var value = this.target[key];
        return value === undefined
            ? null
            : Array.isArray(value)
                ? (_a = value[0]) !== null && _a !== void 0 ? _a : null
                : value;
    };
    FakeURLSearchParams.prototype.getAll = function (key) {
        var value = this.target[key];
        return value === undefined
            ? []
            : Array.isArray(value)
                ? value
                : [value];
    };
    return FakeURLSearchParams;
}());
/**
 * @internal
 */
var TypedQueryRouteInterceptor = /** @class */ (function () {
    function TypedQueryRouteInterceptor(toSearchParams) {
        this.toSearchParams = toSearchParams;
    }
    TypedQueryRouteInterceptor.prototype.intercept = function (context, next) {
        var _this = this;
        var http = context.switchToHttp();
        var response = http.getResponse();
        response.header("Content-Type", "application/x-www-form-urlencoded");
        return next.handle().pipe((0, rxjs_1.map)(function (value) { return _this.toSearchParams(value).toString(); }), (0, rxjs_1.catchError)(function (err) { return (0, route_error_1.route_error)(http.getRequest(), err); }));
    };
    return TypedQueryRouteInterceptor;
}());
/**
 * @internal
 */
var ROUTERS = {
    Get: common_1.Get,
    Post: common_1.Post,
    Patch: common_1.Patch,
    Put: common_1.Put,
    Delete: common_1.Delete,
};
//# sourceMappingURL=TypedQuery.js.map