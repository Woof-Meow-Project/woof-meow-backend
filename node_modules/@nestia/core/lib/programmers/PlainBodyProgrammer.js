"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlainBodyProgrammer = void 0;
var MetadataCollection_1 = require("typia/lib/factories/MetadataCollection");
var MetadataFactory_1 = require("typia/lib/factories/MetadataFactory");
var AssertProgrammer_1 = require("typia/lib/programmers/AssertProgrammer");
var TransformerError_1 = require("typia/lib/transformers/TransformerError");
var PlainBodyProgrammer;
(function (PlainBodyProgrammer) {
    PlainBodyProgrammer.generate = function (project) {
        return function (modulo) {
            return function (type) {
                var result = MetadataFactory_1.MetadataFactory.analyze(project.checker)({
                    escape: false,
                    constant: true,
                    absorb: true,
                    validate: validate,
                })(new MetadataCollection_1.MetadataCollection())(type);
                if (result.success === false)
                    throw TransformerError_1.TransformerError.from("@core.nestia.TypedParam")(result.errors);
                return AssertProgrammer_1.AssertProgrammer.write(__assign(__assign({}, project), { options: {
                        numeric: false,
                        finite: false,
                        functional: false,
                    } }))(modulo)(false)(type);
            };
        };
    };
})(PlainBodyProgrammer || (exports.PlainBodyProgrammer = PlainBodyProgrammer = {}));
var validate = function (metadata) {
    var errors = [];
    var insert = function (msg) { return errors.push(msg); };
    var expected = (metadata.atomics.some(function (a) { return a.type === "string"; }) ? 1 : 0) +
        metadata.templates.length +
        metadata.constants
            .filter(function (c) { return c.type === "string"; })
            .map(function (c) { return c.values.length; })
            .reduce(function (a, b) { return a + b; }, 0);
    if (expected === 0 || expected !== metadata.size())
        insert("only string type is allowed");
    if (metadata.isRequired() === false)
        insert("do not allow undefindable type");
    if (metadata.nullable === true)
        insert("do not allow nullable type");
    else if (metadata.any === true)
        insert("do not allow any type");
    return errors;
};
//# sourceMappingURL=PlainBodyProgrammer.js.map