"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MethodTransformer = void 0;
var typescript_1 = __importDefault(require("typescript"));
var TypedExceptionTransformer_1 = require("./TypedExceptionTransformer");
var TypedRouteTransformer_1 = require("./TypedRouteTransformer");
var MethodTransformer;
(function (MethodTransformer) {
    MethodTransformer.transform = function (project) {
        return function (method) {
            var decorators = typescript_1.default.getDecorators
                ? typescript_1.default.getDecorators(method)
                : method.decorators;
            if (!(decorators === null || decorators === void 0 ? void 0 : decorators.length))
                return method;
            var signature = project.checker.getSignatureFromDeclaration(method);
            var original = signature &&
                project.checker.getReturnTypeOfSignature(signature);
            var escaped = original && get_escaped_type(project.checker)(original);
            if (escaped === undefined)
                return method;
            var operator = function (deco) {
                deco = TypedExceptionTransformer_1.TypedExceptionTransformer.transform(project)(deco);
                deco = TypedRouteTransformer_1.TypedRouteTransformer.transform(project)(escaped)(deco);
                return deco;
            };
            if (typescript_1.default.getDecorators !== undefined)
                return typescript_1.default.factory.updateMethodDeclaration(method, (method.modifiers || []).map(function (mod) {
                    return typescript_1.default.isDecorator(mod) ? operator(mod) : mod;
                }), method.asteriskToken, method.name, method.questionToken, method.typeParameters, method.parameters, method.type, method.body);
            // eslint-disable-next-line
            return typescript_1.default.factory.updateMethodDeclaration(method, decorators.map(operator), method.modifiers, method.asteriskToken, method.name, method.questionToken, method.typeParameters, method.parameters, method.type, method.body);
        };
    };
})(MethodTransformer || (exports.MethodTransformer = MethodTransformer = {}));
var get_escaped_type = function (checker) {
    return function (type) {
        var symbol = type.getSymbol() || type.aliasSymbol;
        return symbol && get_name(symbol) === "Promise"
            ? escape_promise(checker)(type)
            : type;
    };
};
var escape_promise = function (checker) {
    return function (type) {
        var generic = checker.getTypeArguments(type);
        if (generic.length !== 1)
            throw new Error("Error on ImportAnalyzer.analyze(): invalid promise type.");
        return generic[0];
    };
};
var get_name = function (symbol) {
    return explore_name(symbol.getDeclarations()[0].parent)(symbol.escapedName.toString());
};
var explore_name = function (decl) {
    return function (name) {
        return typescript_1.default.isModuleBlock(decl)
            ? explore_name(decl.parent.parent)("".concat(decl.parent.name.getFullText().trim(), ".").concat(name))
            : name;
    };
};
//# sourceMappingURL=MethodTransformer.js.map