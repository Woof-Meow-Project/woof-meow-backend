"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParameterDecoratorTransformer = void 0;
var path_1 = __importDefault(require("path"));
var typescript_1 = __importDefault(require("typescript"));
var PlainBodyProgrammer_1 = require("../programmers/PlainBodyProgrammer");
var TypedBodyProgrammer_1 = require("../programmers/TypedBodyProgrammer");
var TypedHeadersProgrammer_1 = require("../programmers/TypedHeadersProgrammer");
var TypedParamProgrammer_1 = require("../programmers/TypedParamProgrammer");
var TypedQueryBodyProgrammer_1 = require("../programmers/TypedQueryBodyProgrammer");
var TypedQueryProgrammer_1 = require("../programmers/TypedQueryProgrammer");
var ParameterDecoratorTransformer;
(function (ParameterDecoratorTransformer) {
    ParameterDecoratorTransformer.transform = function (project) {
        return function (type) {
            return function (decorator) {
                var _a;
                //----
                // VALIDATIONS
                //----
                // CHECK DECORATOR
                if (!typescript_1.default.isCallExpression(decorator.expression))
                    return decorator;
                // SIGNATURE DECLARATION
                var declaration = (_a = project.checker.getResolvedSignature(decorator.expression)) === null || _a === void 0 ? void 0 : _a.declaration;
                if (declaration === undefined)
                    return decorator;
                // FILE PATH
                var file = path_1.default.resolve(declaration.getSourceFile().fileName);
                if (file.indexOf(LIB_PATH) === -1 && file.indexOf(SRC_PATH) === -1)
                    return decorator;
                //----
                // TRANSFORMATION
                //----
                // FIND PROGRAMMER
                var programmer = FUNCTORS[getName(project.checker.getTypeAtLocation(declaration).symbol)];
                if (programmer === undefined)
                    return decorator;
                // GET TYPE INFO
                var typeNode = project.checker.typeToTypeNode(type, undefined, undefined);
                if (typeNode === undefined)
                    return decorator;
                // DO TRANSFORM
                return typescript_1.default.factory.createDecorator(typescript_1.default.factory.updateCallExpression(decorator.expression, decorator.expression.expression, decorator.expression.typeArguments, programmer(project)(decorator.expression.expression)(decorator.expression.arguments)(type)));
            };
        };
    };
})(ParameterDecoratorTransformer || (exports.ParameterDecoratorTransformer = ParameterDecoratorTransformer = {}));
var FUNCTORS = {
    EncryptedBody: function (project) { return function (modulo) { return function (parameters) { return function (type) {
        return parameters.length
            ? parameters
            : [TypedBodyProgrammer_1.TypedBodyProgrammer.generate(project)(modulo)(type)];
    }; }; }; },
    TypedBody: function (project) { return function (modulo) { return function (parameters) { return function (type) {
        return parameters.length
            ? parameters
            : [TypedBodyProgrammer_1.TypedBodyProgrammer.generate(project)(modulo)(type)];
    }; }; }; },
    TypedHeaders: function (project) { return function (modulo) { return function (parameters) { return function (type) {
        return parameters.length
            ? parameters
            : [TypedHeadersProgrammer_1.TypedHeadersProgrammer.generate(project)(modulo)(type)];
    }; }; }; },
    TypedParam: function (project) { return TypedParamProgrammer_1.TypedParamProgrammer.generate(project); },
    TypedQuery: function (project) { return function (modulo) { return function (parameters) { return function (type) {
        return parameters.length
            ? parameters
            : [TypedQueryProgrammer_1.TypedQueryProgrammer.generate(project)(modulo)(type)];
    }; }; }; },
    "TypedQuery.Body": function (project) { return function (modulo) { return function (parameters) { return function (type) {
        return parameters.length
            ? parameters
            : [TypedQueryBodyProgrammer_1.TypedQueryBodyProgrammer.generate(project)(modulo)(type)];
    }; }; }; },
    PlainBody: function (project) { return function (modulo) { return function (parameters) { return function (type) {
        return parameters.length
            ? parameters
            : [PlainBodyProgrammer_1.PlainBodyProgrammer.generate(project)(modulo)(type)];
    }; }; }; },
};
var LIB_PATH = path_1.default.join("node_modules", "@nestia", "core", "lib", "decorators");
var SRC_PATH = path_1.default.resolve(path_1.default.join(__dirname, "..", "decorators"));
var getName = function (symbol) {
    var _a, _b;
    var parent = (_b = (_a = symbol.getDeclarations()) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.parent;
    return parent
        ? exploreName(parent)(symbol.escapedName.toString())
        : "__type";
};
var exploreName = function (decl) {
    return function (name) {
        return typescript_1.default.isModuleBlock(decl)
            ? exploreName(decl.parent.parent)("".concat(decl.parent.name.getFullText().trim(), ".").concat(name))
            : name;
    };
};
//# sourceMappingURL=ParameterDecoratorTransformer.js.map