"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExceptionManager = void 0;
var fetcher_1 = require("@nestia/fetcher");
var common_1 = require("@nestjs/common");
/**
 * Exception manager for HTTP server.
 *
 * `ExceptionManager` is an utility class who can insert or erase custom error class with
 * its convertion method to a regular {@link nest.HttpException} instance.
 *
 * If you define an API function through {@link TypedRoute} or {@link EncryptedRoute}
 * instead of the basic router decorator functions like {@link nest.Get} or
 * {@link nest.Post} and the API function throws a custom error whose class has been
 * {@link ExceptionManager.insert inserted} in this `EntityManager`, the error would be
 * automatically converted to the regular {@link nest.HttpException} instance by the
 * {@link ExceptionManager.Closure} function.
 *
 * Therefore, with this `ExceptionManager` and {@link TypedRoute} or {@link EncryptedRoute},
 * you can manage your custom error classes much systemtically. You can avoid 500 internal
 * server error or hard coding implementation about the custom error classes.
 *
 * Below error classes are defaultly configured in this `ExceptionManager`
 *
 *   - `typia.TypeGuardError`
 *   - `@nestia/fetcher.HttpError`
 *
 * @author Jeongho Nam - https://github.com/samchon
 */
var ExceptionManager;
(function (ExceptionManager) {
    /**
     * Insert an error class with converter.
     *
     * If you've inserted an duplicated error class, the closure would be overwritten.
     *
     * @param creator Target error class
     * @param closure A closure function converting to the `HttpException` class
     */
    function insert(creator, closure) {
        var index = ExceptionManager.tuples.findIndex(function (tuple) { return tuple[0] === creator; });
        if (index !== -1)
            ExceptionManager.tuples.splice(index, 1);
        ExceptionManager.tuples.push([creator, closure]);
        ExceptionManager.tuples.sort(function (_a, _b) {
            var _c = __read(_a, 1), x = _c[0];
            var _d = __read(_b, 1), y = _d[0];
            return (x.prototype instanceof y ? -1 : 1);
        });
    }
    ExceptionManager.insert = insert;
    /**
     * Erase an error class.
     *
     * @param creator Target error class
     * @returns Whether be erased or not
     */
    function erase(creator) {
        var index = ExceptionManager.tuples.findIndex(function (tuple) { return tuple[0] === creator; });
        if (index === -1)
            return false;
        ExceptionManager.tuples.splice(index, 1);
        return true;
    }
    ExceptionManager.erase = erase;
    function on(closure) {
        ExceptionManager.listeners.add(closure);
    }
    ExceptionManager.on = on;
    function off(closure) {
        ExceptionManager.listeners.delete(closure);
    }
    ExceptionManager.off = off;
    /**
     * @internal
     */
    ExceptionManager.tuples = [];
    /**
     * @internal
     */
    ExceptionManager.listeners = new Set();
})(ExceptionManager || (exports.ExceptionManager = ExceptionManager = {}));
ExceptionManager.insert(fetcher_1.HttpError, function (error) {
    return new common_1.HttpException({
        path: error.path,
        message: error.message,
    }, error.status);
});
//# sourceMappingURL=ExceptionManager.js.map