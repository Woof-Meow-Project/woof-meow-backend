/**
 * Test validator.
 *
 * `TestValidator` is a collection gathering E2E validation functions.
 *
 * @author Jeongho Nam - https://github.com/samchon
 */
export declare namespace TestValidator {
    /**
     * Test whether condition is satisfied.
     *
     * @param title Title of error message when condition is not satisfied
     * @return Currying function
     */
    const predicate: (title: string) => <T extends boolean | (() => boolean) | (() => Promise<boolean>)>(condition: T) => T extends () => Promise<boolean> ? Promise<void> : void;
    /**
     * Test whether two values are equal.
     *
     * If you want to validate `covers` relationship,
     * call smaller first and then larger.
     *
     * Otherwise you wanna non equals validator, combine with {@link error}.
     *
     * @param title Title of error message when different
     * @param exception Exception filter for ignoring some keys
     * @returns Currying function
     */
    const equals: (title: string, exception?: (key: string) => boolean) => <T>(x: T) => (y: T) => void;
    /**
     * Test whether error occurs.
     *
     * If error occurs, nothing would be happened.
     *
     * However, no error exists, then exception would be thrown.
     *
     * @param title Title of exception because of no error exists
     */
    const error: (title: string) => <T>(task: () => T) => T extends Promise<any> ? Promise<void> : void;
    const httpError: (title: string) => (status: number) => <T>(task: () => T) => T extends Promise<any> ? Promise<void> : void;
    function proceed(task: () => Promise<any>): Promise<Error | null>;
    function proceed(task: () => any): Error | null;
    /**
     * Validate index API.
     *
     * Test whether two indexed values are equal.
     *
     * If two values are different, then exception would be thrown.
     *
     * @param title Title of error message when different
     * @return Currying function
     *
     * @example https://github.com/samchon/nestia-template/blob/master/src/test/features/api/bbs/test_api_bbs_article_index_search.ts
     */
    const index: (title: string) => <Solution extends IEntity<any>>(expected: Solution[]) => <Summary extends IEntity<any>>(gotten: Summary[], trace?: boolean) => void;
    /**
     * Valiate search options.
     *
     * Test a pagination API supporting search options.
     *
     * @param title Title of error message when searching is invalid
     * @returns Currying function
     *
     * @example https://github.com/samchon/nestia-template/blob/master/src/test/features/api/bbs/test_api_bbs_article_index_search.ts
     */
    const search: (title: string) => <Entity extends IEntity<any>, Request_1>(getter: (input: Request_1) => Promise<Entity[]>) => (total: Entity[], sampleCount?: number) => <Values extends any[]>(props: ISearchProps<Entity, Values, Request_1>) => Promise<void>;
    interface ISearchProps<Entity extends IEntity<any>, Values extends any[], Request> {
        fields: string[];
        values(entity: Entity): Values;
        filter(entity: Entity, values: Values): boolean;
        request(values: Values): Request;
    }
    /**
     * Validate sorting options.
     *
     * Test a pagination API supporting sorting options.
     *
     * You can validate detailed sorting options both asceding and descending orders
     * with multiple fields. However, as it forms a complicate currying function,
     * I recomend you to see below example code before using.
     *
     * @param title Title of error message when sorting is invalid
     * @example https://github.com/samchon/nestia-template/blob/master/src/test/features/api/bbs/test_api_bbs_article_index_sort.ts
     */
    const sort: (title: string) => <T extends object, Fields extends string, Sortable_1 extends (`-${Fields}` | `+${Fields}`)[]>(getter: (sortable: Sortable_1) => Promise<T[]>) => (...fields: Fields[]) => (comp: (x: T, y: T) => number, filter?: ((elem: T) => boolean) | undefined) => (direction: "+" | "-", trace?: boolean) => Promise<void>;
    type Sortable<Literal extends string> = Array<`-${Literal}` | `+${Literal}`>;
}
interface IEntity<Type extends string | number | bigint> {
    id: Type;
}
export {};
