"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestValidator = void 0;
var ranges_1 = require("tstl/ranges");
var RandomGenerator_1 = require("./RandomGenerator");
var json_equal_to_1 = require("./internal/json_equal_to");
/**
 * Test validator.
 *
 * `TestValidator` is a collection gathering E2E validation functions.
 *
 * @author Jeongho Nam - https://github.com/samchon
 */
var TestValidator;
(function (TestValidator) {
    var _this = this;
    /**
     * Test whether condition is satisfied.
     *
     * @param title Title of error message when condition is not satisfied
     * @return Currying function
     */
    TestValidator.predicate = function (title) {
        return function (condition) {
            var message = function () {
                return "Bug on ".concat(title, ": expected condition is not satisfied.");
            };
            // SCALAR
            if (typeof condition === "boolean") {
                if (condition !== true)
                    throw new Error(message());
                return undefined;
            }
            // CLOSURE
            var output = condition();
            if (typeof output === "boolean") {
                if (output !== true)
                    throw new Error(message());
                return undefined;
            }
            // ASYNCHRONOUS
            return new Promise(function (resolve, reject) {
                output
                    .then(function (flag) {
                    if (flag === true)
                        resolve();
                    else
                        reject(message());
                })
                    .catch(reject);
            });
        };
    };
    /**
     * Test whether two values are equal.
     *
     * If you want to validate `covers` relationship,
     * call smaller first and then larger.
     *
     * Otherwise you wanna non equals validator, combine with {@link error}.
     *
     * @param title Title of error message when different
     * @param exception Exception filter for ignoring some keys
     * @returns Currying function
     */
    TestValidator.equals = function (title, exception) {
        if (exception === void 0) { exception = function () { return false; }; }
        return function (x) {
            return function (y) {
                var diff = (0, json_equal_to_1.json_equal_to)(exception)(x)(y);
                if (diff.length)
                    throw new Error("Bug on ".concat(title, ": found different values - [").concat(diff.join(", "), "]"));
            };
        };
    };
    /**
     * Test whether error occurs.
     *
     * If error occurs, nothing would be happened.
     *
     * However, no error exists, then exception would be thrown.
     *
     * @param title Title of exception because of no error exists
     */
    TestValidator.error = function (title) {
        return function (task) {
            var message = function () { return "Bug on ".concat(title, ": exception must be thrown."); };
            try {
                var output_1 = task();
                if (is_promise(output_1))
                    return new Promise(function (resolve, reject) {
                        return output_1
                            .catch(function () { return resolve(); })
                            .then(function () { return reject(message()); });
                    });
                else
                    throw new Error(message());
            }
            catch (_a) {
                return undefined;
            }
        };
    };
    TestValidator.httpError = function (title) {
        return function (status) {
            return function (task) {
                var message = function (actual) {
                    return typeof actual === "number"
                        ? "Bug on ".concat(title, ": status code must be ").concat(status, ", but ").concat(actual, ".")
                        : "Bug on ".concat(title, ": status code must be ").concat(status, ", but succeeded.");
                };
                var predicate = function (exp) {
                    return typeof exp === "object" &&
                        exp.constructor.name === "HttpError" &&
                        exp.status === status
                        ? null
                        : new Error(message(typeof exp === "object" &&
                            exp.constructor.name === "HttpError"
                            ? exp.status
                            : undefined));
                };
                try {
                    var output_2 = task();
                    if (is_promise(output_2))
                        return new Promise(function (resolve, reject) {
                            return output_2
                                .catch(function (exp) {
                                var res = predicate(exp);
                                if (res)
                                    reject(res);
                                else
                                    resolve();
                            })
                                .then(function () { return reject(new Error(message())); });
                        });
                    else
                        throw new Error(message());
                }
                catch (exp) {
                    var res = predicate(exp);
                    if (res)
                        throw res;
                    return undefined;
                }
            };
        };
    };
    function proceed(task) {
        try {
            var output_3 = task();
            if (is_promise(output_3))
                return new Promise(function (resolve) {
                    return output_3
                        .catch(function (exp) { return resolve(exp); })
                        .then(function () { return resolve(null); });
                });
        }
        catch (exp) {
            return exp;
        }
        return null;
    }
    TestValidator.proceed = proceed;
    /**
     * Validate index API.
     *
     * Test whether two indexed values are equal.
     *
     * If two values are different, then exception would be thrown.
     *
     * @param title Title of error message when different
     * @return Currying function
     *
     * @example https://github.com/samchon/nestia-template/blob/master/src/test/features/api/bbs/test_api_bbs_article_index_search.ts
     */
    TestValidator.index = function (title) {
        return function (expected) {
            return function (gotten, trace) {
                if (trace === void 0) { trace = true; }
                var length = Math.min(expected.length, gotten.length);
                expected = expected.slice(0, length);
                gotten = gotten.slice(0, length);
                var xIds = get_ids(expected).slice(0, length);
                var yIds = get_ids(gotten)
                    .filter(function (id) { return id >= xIds[0]; })
                    .slice(0, length);
                var equals = xIds.every(function (x, i) { return x === yIds[i]; });
                if (equals === true)
                    return;
                else if (trace === true)
                    console.log({
                        expected: xIds,
                        gotten: yIds,
                    });
                throw new Error("Bug on ".concat(title, ": result of the index is different with manual aggregation."));
            };
        };
    };
    /**
     * Valiate search options.
     *
     * Test a pagination API supporting search options.
     *
     * @param title Title of error message when searching is invalid
     * @returns Currying function
     *
     * @example https://github.com/samchon/nestia-template/blob/master/src/test/features/api/bbs/test_api_bbs_article_index_search.ts
     */
    TestValidator.search = function (title) {
        /**
         * @param getter A pagination API function to be called
         */
        return function (getter) {
            /**
             * @param total Total entity records for comparison
             * @param sampleCount Sampling count. Default is 1
             */
            return function (total, sampleCount) {
                if (sampleCount === void 0) { sampleCount = 1; }
                /**
                 * @param props Search properties
                 */
                return function (props) { return __awaiter(_this, void 0, void 0, function () {
                    var samples, _loop_1, samples_1, samples_1_1, s, e_1_1;
                    var e_1, _a;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                samples = RandomGenerator_1.RandomGenerator.sample(total)(sampleCount);
                                _loop_1 = function (s) {
                                    var values, filtered, gotten;
                                    return __generator(this, function (_c) {
                                        switch (_c.label) {
                                            case 0:
                                                values = props.values(s);
                                                filtered = total.filter(function (entity) {
                                                    return props.filter(entity, values);
                                                });
                                                return [4 /*yield*/, getter(props.request(values))];
                                            case 1:
                                                gotten = _c.sent();
                                                TestValidator.index("".concat(title, " (").concat(props.fields.join(", "), ")"))(filtered)(gotten);
                                                return [2 /*return*/];
                                        }
                                    });
                                };
                                _b.label = 1;
                            case 1:
                                _b.trys.push([1, 6, 7, 8]);
                                samples_1 = __values(samples), samples_1_1 = samples_1.next();
                                _b.label = 2;
                            case 2:
                                if (!!samples_1_1.done) return [3 /*break*/, 5];
                                s = samples_1_1.value;
                                return [5 /*yield**/, _loop_1(s)];
                            case 3:
                                _b.sent();
                                _b.label = 4;
                            case 4:
                                samples_1_1 = samples_1.next();
                                return [3 /*break*/, 2];
                            case 5: return [3 /*break*/, 8];
                            case 6:
                                e_1_1 = _b.sent();
                                e_1 = { error: e_1_1 };
                                return [3 /*break*/, 8];
                            case 7:
                                try {
                                    if (samples_1_1 && !samples_1_1.done && (_a = samples_1.return)) _a.call(samples_1);
                                }
                                finally { if (e_1) throw e_1.error; }
                                return [7 /*endfinally*/];
                            case 8: return [2 /*return*/];
                        }
                    });
                }); };
            };
        };
    };
    /**
     * Validate sorting options.
     *
     * Test a pagination API supporting sorting options.
     *
     * You can validate detailed sorting options both asceding and descending orders
     * with multiple fields. However, as it forms a complicate currying function,
     * I recomend you to see below example code before using.
     *
     * @param title Title of error message when sorting is invalid
     * @example https://github.com/samchon/nestia-template/blob/master/src/test/features/api/bbs/test_api_bbs_article_index_sort.ts
     */
    TestValidator.sort = function (title) {
        /**
         * @param getter A pagination API function to be called
         */
        return function (getter) {
            /**
             * @param fields List of fields to be sorted
             */
            return function () {
                var fields = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    fields[_i] = arguments[_i];
                }
                /**
                 * @param comp Comparator function for validation
                 * @param filter Filter function for data if required
                 */
                return function (comp, filter) {
                    /**
                     * @param direction "+" means ascending order, and "-" means descending order
                     */
                    return function (direction, trace) {
                        if (trace === void 0) { trace = true; }
                        return __awaiter(_this, void 0, void 0, function () {
                            var data, reversed;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, getter(fields.map(function (field) { return "".concat(direction).concat(field); }))];
                                    case 1:
                                        data = _a.sent();
                                        if (filter)
                                            data = data.filter(filter);
                                        reversed = direction === "+" ? comp : function (x, y) { return comp(y, x); };
                                        if ((0, ranges_1.is_sorted)(data, function (x, y) { return reversed(x, y) < 0; }) === false) {
                                            if (fields.length === 1 &&
                                                data.length &&
                                                data[0][fields[0]] !== undefined &&
                                                trace)
                                                console.log(data.map(function (elem) { return elem[fields[0]]; }));
                                            throw new Error("Bug on ".concat(title, ": wrong sorting on ").concat(direction, "(").concat(fields.join(", "), ")."));
                                        }
                                        return [2 /*return*/];
                                }
                            });
                        });
                    };
                };
            };
        };
    };
})(TestValidator || (exports.TestValidator = TestValidator = {}));
function get_ids(entities) {
    return entities.map(function (entity) { return entity.id; }).sort(function (x, y) { return (x < y ? -1 : 1); });
}
function is_promise(input) {
    return (typeof input === "object" &&
        input !== null &&
        typeof input.then === "function" &&
        typeof input.catch === "function");
}
//# sourceMappingURL=TestValidator.js.map