"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NestiaSdkApplication = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const tstl_1 = require("tstl");
const typescript_1 = __importDefault(require("typescript"));
const AccessorAnalyzer_1 = require("./analyses/AccessorAnalyzer");
const ControllerAnalyzer_1 = require("./analyses/ControllerAnalyzer");
const ReflectAnalyzer_1 = require("./analyses/ReflectAnalyzer");
const E2eGenerator_1 = require("./generates/E2eGenerator");
const SdkGenerator_1 = require("./generates/SdkGenerator");
const SwaggerGenerator_1 = require("./generates/SwaggerGenerator");
const ArrayUtil_1 = require("./utils/ArrayUtil");
const NestiaConfigUtil_1 = require("./utils/NestiaConfigUtil");
const SourceFinder_1 = require("./utils/SourceFinder");
class NestiaSdkApplication {
    constructor(config, compilerOptions) {
        this.config = config;
        this.compilerOptions = compilerOptions;
        this.bundler_ = new tstl_1.Singleton(() => __awaiter(this, void 0, void 0, function* () {
            if (!this.config)
                return () => false;
            const bundles = yield fs_1.default.promises.readdir(SdkGenerator_1.SdkGenerator.BUNDLE_PATH);
            const tuples = yield ArrayUtil_1.ArrayUtil.asyncMap(bundles, (file) => __awaiter(this, void 0, void 0, function* () {
                const relative = path_1.default.join(this.config.output, file);
                const location = path_1.default.join(SdkGenerator_1.SdkGenerator.BUNDLE_PATH, file);
                const stats = yield fs_1.default.promises.stat(location);
                return new tstl_1.Pair(relative, stats.isDirectory());
            }));
            return (file) => {
                for (const it of tuples)
                    if (it.second === false && file === it.first)
                        return true;
                    else if (it.second === true && file.indexOf(it.first) === 0)
                        return true;
                return false;
            };
        }));
    }
    is_not_excluded(file) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.config.output)
                return (file.indexOf(path_1.default.join(this.config.output, "functional")) ===
                    -1 && (yield this.bundler_.get())(file) === false);
            const content = yield fs_1.default.promises.readFile(file, "utf8");
            return (content.indexOf(" * @nestia Generated by Nestia - https://github.com/samchon/nestia") === -1);
        });
    }
    e2e() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.config.output)
                throw new Error("Error on NestiaApplication.e2e(): output path of SDK is not specified.");
            else if (!this.config.e2e)
                throw new Error("Error on NestiaApplication.e2e(): output path of e2e test files is not specified.");
            const validate = (title) => (location) => __awaiter(this, void 0, void 0, function* () {
                const parent = path_1.default.resolve(location + "/..");
                const stats = yield fs_1.default.promises.lstat(parent);
                if (stats.isDirectory() === false)
                    throw new Error(`Error on NestiaApplication.e2e(): output directory of ${title} does not exists.`);
            });
            yield validate("sdk")(this.config.output);
            yield validate("e2e")(this.config.e2e);
            title("Nestia E2E Generator");
            yield this.generate("e2e", (config) => config, (checker) => (config) => (routes) => __awaiter(this, void 0, void 0, function* () {
                yield SdkGenerator_1.SdkGenerator.generate(checker)(config)(routes);
                yield E2eGenerator_1.E2eGenerator.generate(config)(routes);
            }));
        });
    }
    sdk() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.config.output)
                throw new Error("Error on NestiaApplication.sdk(): output path is not specified.");
            const parent = path_1.default.resolve(this.config.output + "/..");
            const stats = yield fs_1.default.promises.lstat(parent);
            if (stats.isDirectory() === false)
                throw new Error("Error on NestiaApplication.sdk(): output directory does not exists.");
            title("Nestia SDK Generator");
            yield this.generate("sdk", (config) => config, SdkGenerator_1.SdkGenerator.generate);
        });
    }
    swagger() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!((_a = this.config.swagger) === null || _a === void 0 ? void 0 : _a.output))
                throw new Error(`Error on NestiaApplication.swagger(): output path of the "swagger.json" is not specified.`);
            const parsed = path_1.default.parse(this.config.swagger.output);
            const directory = !!parsed.ext
                ? path_1.default.resolve(parsed.dir)
                : this.config.swagger.output;
            const stats = yield fs_1.default.promises.lstat(directory);
            if (stats.isDirectory() === false)
                throw new Error("Error on NestiaApplication.swagger(): output directory does not exists.");
            title("Nestia Swagger Generator");
            yield this.generate("swagger", (config) => config.swagger, SwaggerGenerator_1.SwaggerGenerator.generate);
        });
    }
    generate(method, config, archiver) {
        return __awaiter(this, void 0, void 0, function* () {
            // LOAD CONTROLLER FILES
            const input = NestiaConfigUtil_1.NestiaConfigUtil.input(this.config.input);
            const fileList = yield ArrayUtil_1.ArrayUtil.asyncFilter(yield SourceFinder_1.SourceFinder.find({
                include: input.include,
                exclude: input.exclude,
                filter: (file) => file.substring(file.length - 3) === ".ts" &&
                    file.substring(file.length - 5) !== ".d.ts",
            }), (file) => this.is_not_excluded(file));
            // ANALYZE REFLECTS
            const unique = new WeakSet();
            const controllers = [];
            console.log("Analyzing reflections");
            for (const file of fileList)
                controllers.push(...(yield ReflectAnalyzer_1.ReflectAnalyzer.analyze(unique, file)));
            const agg = (() => {
                const set = new Set();
                for (const c of controllers)
                    for (const cPath of c.paths)
                        for (const f of c.functions)
                            for (const fPath of f.paths)
                                set.add(`${f.method}::${cPath}/${fPath}`);
                return set.size;
            })();
            console.log(`  - controllers: #${controllers.length}`);
            console.log(`  - paths: #${agg}`);
            console.log(`  - routes: #${controllers
                .map((c) => c.paths.length *
                c.functions
                    .map((f) => f.paths.length)
                    .reduce((a, b) => a + b, 0))
                .reduce((a, b) => a + b, 0)}`);
            // ANALYZE TYPESCRIPT CODE
            console.log("Analyzing source codes");
            const program = typescript_1.default.createProgram(controllers.map((c) => c.file), this.compilerOptions);
            const checker = program.getTypeChecker();
            const routeList = [];
            for (const c of controllers) {
                const file = program.getSourceFile(c.file);
                if (file === undefined)
                    continue;
                routeList.push(...ControllerAnalyzer_1.ControllerAnalyzer.analyze(checker, file, c));
            }
            // FIND IMPLICIT TYPES
            const implicit = routeList.filter(is_implicit_return_typed);
            if (implicit.length > 0)
                throw new Error(`NestiaApplication.${method}(): implicit return type is not allowed.\n` +
                    "\n" +
                    "List of implicit return typed routes:\n" +
                    implicit
                        .map((it) => `  - ${it.symbol.class}.${it.symbol.function} at "${it.location}"`)
                        .join("\n"));
            // DO GENERATE
            AccessorAnalyzer_1.AccessorAnalyzer.analyze(routeList);
            yield archiver(checker)(config(this.config))(routeList);
        });
    }
}
exports.NestiaSdkApplication = NestiaSdkApplication;
const title = (str) => {
    console.log("-----------------------------------------------------------");
    console.log(` ${str}`);
    console.log("-----------------------------------------------------------");
};
const is_implicit_return_typed = (route) => {
    const name = route.output.typeName;
    if (name === "void")
        return false;
    else if (name.indexOf("readonly [") !== -1)
        return true;
    const pos = name.indexOf("__object");
    if (pos === -1)
        return false;
    const before = pos - 1;
    const after = pos + "__object".length;
    for (const i of [before, after])
        if (name[i] === undefined)
            continue;
        else if (VARIABLE.test(name[i]))
            return false;
    return true;
};
const VARIABLE = /[a-zA-Z_$0-9]/;
//# sourceMappingURL=NestiaSdkApplication.js.map