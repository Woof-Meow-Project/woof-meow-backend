"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ControllerAnalyzer = void 0;
const path_1 = __importDefault(require("path"));
const HashMap_1 = require("tstl/container/HashMap");
const typescript_1 = __importDefault(require("typescript"));
const CommentFactory_1 = require("typia/lib/factories/CommentFactory");
const PathUtil_1 = require("../utils/PathUtil");
const ExceptionAnalyzer_1 = require("./ExceptionAnalyzer");
const GenericAnalyzer_1 = require("./GenericAnalyzer");
const ImportAnalyzer_1 = require("./ImportAnalyzer");
const PathAnalyzer_1 = require("./PathAnalyzer");
const SecurityAnalyzer_1 = require("./SecurityAnalyzer");
var ControllerAnalyzer;
(function (ControllerAnalyzer) {
    function analyze(checker, sourceFile, controller) {
        // FIND CONTROLLER CLASS
        const ret = [];
        typescript_1.default.forEachChild(sourceFile, (node) => {
            var _a;
            if (typescript_1.default.isClassDeclaration(node) &&
                ((_a = node.name) === null || _a === void 0 ? void 0 : _a.escapedText) === controller.name) {
                // ANALYZE THE CONTROLLER
                ret.push(..._Analyze_controller(checker, controller, node));
                return;
            }
        });
        return ret;
    }
    ControllerAnalyzer.analyze = analyze;
    /* ---------------------------------------------------------
        CLASS
    --------------------------------------------------------- */
    function _Analyze_controller(checker, controller, classNode) {
        const classType = checker.getTypeAtLocation(classNode);
        const genericDict = GenericAnalyzer_1.GenericAnalyzer.analyze(checker, classNode);
        const ret = [];
        for (const property of classType.getProperties()) {
            // GET METHOD DECLARATION
            const declaration = (property.declarations || [])[0];
            if (!declaration || !typescript_1.default.isMethodDeclaration(declaration))
                continue;
            // IDENTIFIER MUST BE
            const identifier = declaration.name;
            if (!typescript_1.default.isIdentifier(identifier))
                continue;
            // ANALYZED WITH THE REFLECTED-FUNCTION
            const runtime = controller.functions.find((f) => f.name === identifier.escapedText);
            if (runtime === undefined)
                continue;
            const routes = _Analyze_function(checker, controller, genericDict, runtime, declaration, property);
            ret.push(...routes);
        }
        return ret;
    }
    /* ---------------------------------------------------------
        FUNCTION
    --------------------------------------------------------- */
    function _Analyze_function(checker, controller, genericDict, func, declaration, symbol) {
        var _a, _b;
        // PREPARE ASSETS
        const type = checker.getTypeOfSymbolAtLocation(symbol, symbol.valueDeclaration);
        const signature = checker.getSignaturesOfType(type, typescript_1.default.SignatureKind.Call)[0];
        if (signature === undefined)
            throw new Error(`Error on ControllerAnalyzer.analyze(): unable to get the signature from the ${controller.name}.${func.name}().`);
        const importDict = new HashMap_1.HashMap();
        // EXPLORE CHILDREN TYPES
        const parameters = func.parameters.map((param) => _Analyze_parameter(checker, genericDict, importDict, controller, func.name, param, signature.getParameters()[param.index]));
        const outputType = ImportAnalyzer_1.ImportAnalyzer.analyze(checker, genericDict, importDict, signature.getReturnType());
        if (outputType === null)
            throw new Error(`Error on ControllerAnalyzer.analyze(): unnamed return type from ${controller.name}.${func.name}().`);
        else if (func.method === "HEAD" &&
            outputType.typeName !== "void" &&
            outputType.typeName !== "undefined")
            throw new Error(`Error on ControllerAnalyzer.analyze(): HEAD method must return void type - ${controller.name}.${func.name}().`);
        const imports = importDict
            .toJSON()
            .map((pair) => [pair.first, pair.second.toJSON()]);
        // PARSE COMMENT TAGS
        const jsDocTags = signature.getJsDocTags();
        const security = SecurityAnalyzer_1.SecurityAnalyzer.merge(...controller.security, ...func.security, ...jsDocTags
            .filter((tag) => tag.name === "security")
            .map((tag) => {
            var _a;
            return ((_a = tag.text) !== null && _a !== void 0 ? _a : []).map((text) => {
                const line = text.text
                    .split(" ")
                    .filter((s) => s.trim())
                    .filter((s) => !!s.length);
                if (line.length === 0)
                    return {};
                return {
                    [line[0]]: line.slice(1),
                };
            });
        })
            .flat());
        // CONSTRUCT COMMON DATA
        const common = Object.assign(Object.assign({}, func), { parameters, output: {
                type: outputType.type,
                typeName: outputType.typeName,
                contentType: func.contentType,
            }, imports, status: func.status, symbol: {
                class: controller.name,
                function: func.name,
            }, location: (() => {
                const file = declaration.getSourceFile();
                const { line, character } = file.getLineAndCharacterOfPosition(declaration.pos);
                return `${path_1.default.relative(process.cwd(), file.fileName)}:${line + 1}:${character + 1}`;
            })(), description: CommentFactory_1.CommentFactory.description(symbol), operationId: (_b = (_a = jsDocTags
                .find(({ name }) => name === "operationId")) === null || _a === void 0 ? void 0 : _a.text) === null || _b === void 0 ? void 0 : _b[0].text.split(" ")[0].trim(), jsDocTags: jsDocTags, setHeaders: jsDocTags
                .filter((t) => {
                var _a;
                return ((_a = t.text) === null || _a === void 0 ? void 0 : _a.length) &&
                    t.text[0].text &&
                    (t.name === "setHeader" || t.name === "assignHeaders");
            })
                .map((t) => {
                var _a;
                return t.name === "setHeader"
                    ? {
                        type: "setter",
                        source: t.text[0].text.split(" ")[0].trim(),
                        target: (_a = t.text[0].text.split(" ")[1]) === null || _a === void 0 ? void 0 : _a.trim(),
                    }
                    : {
                        type: "assigner",
                        source: t.text[0].text,
                    };
            }), security, exceptions: ExceptionAnalyzer_1.ExceptionAnalyzer.analyze(checker)(genericDict, importDict)(func)(declaration) });
        // CONFIGURE PATHS
        const pathList = [];
        for (const controllerPath of controller.paths)
            for (const filePath of func.paths) {
                const path = PathAnalyzer_1.PathAnalyzer.join(controllerPath, filePath);
                pathList.push(PathAnalyzer_1.PathAnalyzer.espace(path, () => "ControllerAnalyzer.analyze()"));
            }
        // RETURNS
        return pathList.map((path) => (Object.assign(Object.assign({}, common), { path, accessors: [...PathUtil_1.PathUtil.accessors(path), func.name] })));
    }
    function _Analyze_parameter(checker, genericDict, importDict, controller, funcName, param, symbol) {
        var _a;
        const type = checker.getTypeOfSymbolAtLocation(symbol, symbol.valueDeclaration);
        const name = symbol.getEscapedName().toString();
        const method = `${controller.name}.${funcName}()`;
        const optional = !!((_a = checker.symbolToParameterDeclaration(symbol, undefined, undefined)) === null || _a === void 0 ? void 0 : _a.questionToken);
        // DO NOT SUPPORT BODY PARAMETER
        if (param.category === "body" && param.field !== undefined)
            throw new Error(`Error on ${method}: nestia does not support body field specification. ` +
                `Therefore, erase the ${method}#${name} parameter and ` +
                `re-define a new body decorator accepting full structured message.`);
        else if (optional === true && param.category !== "query")
            throw new Error(`Error on ${method}: nestia does not support optional parameter except query parameter. ` +
                `Therefore, erase question mark on ${method}#${name} parameter, ` +
                `or re-define a new method without the "name" parameter.`);
        else if (optional === true &&
            param.category === "query" &&
            param.field === undefined)
            throw new Error(`Error on ${method}: nestia does not support optional query parameter without field specification. ` +
                `Therefore, erase question mark on ${method}#${name} parameter, ` +
                `or re-define re-define parameters for each query parameters.`);
        // GET TYPE NAME
        const tuple = ImportAnalyzer_1.ImportAnalyzer.analyze(checker, genericDict, importDict, type);
        if (tuple === null)
            throw new Error(`Error on ${method}: unnamed parameter type from ${method}#${name}.`);
        return Object.assign(Object.assign({}, param), { name,
            optional, type: tuple.type, typeName: tuple.typeName });
    }
})(ControllerAnalyzer || (exports.ControllerAnalyzer = ControllerAnalyzer = {}));
//# sourceMappingURL=ControllerAnalyzer.js.map