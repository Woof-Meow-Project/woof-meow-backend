"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExceptionAnalyzer = void 0;
const path_1 = __importDefault(require("path"));
const typescript_1 = __importDefault(require("typescript"));
const ImportAnalyzer_1 = require("./ImportAnalyzer");
var ExceptionAnalyzer;
(function (ExceptionAnalyzer) {
    ExceptionAnalyzer.analyze = (checker) => (genericDict, importDict) => (func) => (declaration) => {
        var _a;
        const output = {};
        for (const decorator of (_a = declaration.modifiers) !== null && _a !== void 0 ? _a : [])
            if (typescript_1.default.isDecorator(decorator))
                analyzeTyped(checker)(genericDict, importDict)(func)(output)(decorator);
        return output;
    };
    const analyzeTyped = (checker) => (genericDict, importDict) => (func) => (output) => (decorator) => {
        var _a;
        // CHECK DECORATOR
        if (!typescript_1.default.isCallExpression(decorator.expression))
            return false;
        else if (((_a = decorator.expression.typeArguments) !== null && _a !== void 0 ? _a : []).length !== 1)
            return false;
        // CHECK SIGNATURE
        const signature = checker.getResolvedSignature(decorator.expression);
        if (!signature || !signature.declaration)
            return false;
        else if (path_1.default
            .resolve(signature.declaration.getSourceFile().fileName)
            .indexOf(TYPED_EXCEPTION_PATH) === -1)
            return false;
        // GET TYPE INFO
        const node = decorator.expression.typeArguments[0];
        const type = checker.getTypeFromTypeNode(node);
        if (type.isTypeParameter())
            throw new Error("Error on @nestia.core.TypedException(): non-specified generic argument.");
        const tuple = ImportAnalyzer_1.ImportAnalyzer.analyze(checker, genericDict, importDict, type);
        if (tuple === null)
            return false;
        // DO ASSIGN
        const matched = Object.entries(func.exceptions)
            .filter(([_key, value]) => value.type === tuple.typeName)
            .map(([_key, value]) => value);
        for (const m of matched)
            output[m.status] = {
                type: tuple.type,
                typeName: tuple.typeName,
                contentType: "application/json",
                description: m.description,
            };
        return true;
    };
})(ExceptionAnalyzer || (exports.ExceptionAnalyzer = ExceptionAnalyzer = {}));
const TYPED_EXCEPTION_PATH = path_1.default.join("node_modules", "@nestia", "core", "lib", "decorators", "TypedException.d.ts");
//# sourceMappingURL=ExceptionAnalyzer.js.map