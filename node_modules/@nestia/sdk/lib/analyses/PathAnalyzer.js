"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PathAnalyzer = void 0;
const path_1 = __importDefault(require("path"));
const path_to_regexp_1 = require("path-to-regexp");
var PathAnalyzer;
(function (PathAnalyzer) {
    PathAnalyzer.join = (...args) => "/" +
        _Trim(path_1.default
            .join(...args)
            .split("\\")
            .join("/"));
    PathAnalyzer.espace = (str, method) => "/" +
        _Parse(str, method)
            .map((arg) => (arg.type === "param" ? `:${arg.value}` : arg.value))
            .join("/");
    PathAnalyzer.parameters = (str, method) => _Parse(str, method)
        .filter((arg) => arg.type === "param")
        .map((arg) => arg.value);
    function _Parse(str, method) {
        const tokens = (0, path_to_regexp_1.parse)(path_1.default.join(str).split("\\").join("/"));
        const output = [];
        for (const key of tokens) {
            if (typeof key === "string")
                output.push({
                    type: "path",
                    value: _Trim(key),
                });
            else if (typeof key.name === "number" || _Trim(key.name) === "")
                throw new Error(`Error on ${method}: ${ERROR_MESSAGE}.`);
            else
                output.push({
                    type: "param",
                    value: _Trim(key.name),
                });
        }
        return output;
    }
    function _Trim(str) {
        if (str[0] === "/")
            str = str.substring(1);
        if (str[str.length - 1] === "/")
            str = str.substring(0, str.length - 1);
        return str;
    }
})(PathAnalyzer || (exports.PathAnalyzer = PathAnalyzer = {}));
const ERROR_MESSAGE = "nestia supports only string typed parameter on path";
//# sourceMappingURL=PathAnalyzer.js.map