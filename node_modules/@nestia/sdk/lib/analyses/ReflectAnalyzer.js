"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReflectAnalyzer = void 0;
const Constants = __importStar(require("@nestjs/common/constants"));
require("reflect-metadata");
const module_1 = require("tstl/ranges/module");
const ArrayUtil_1 = require("../utils/ArrayUtil");
const PathAnalyzer_1 = require("./PathAnalyzer");
const SecurityAnalyzer_1 = require("./SecurityAnalyzer");
var ReflectAnalyzer;
(function (ReflectAnalyzer) {
    function analyze(unique, file) {
        return __awaiter(this, void 0, void 0, function* () {
            const module = yield (() => __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield Promise.resolve(`${file}`).then(s => __importStar(require(s)));
                }
                catch (exp) {
                    console.log(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                    console.log(`Error on "${file}" file. Check your code.`);
                    console.log(exp);
                    console.log(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                    process.exit(-1);
                }
            }))();
            const ret = [];
            for (const tuple of Object.entries(module)) {
                if (unique.has(tuple[1]))
                    continue;
                else
                    unique.add(tuple[1]);
                const controller = _Analyze_controller(file, ...tuple);
                if (controller !== null)
                    ret.push(controller);
            }
            return ret;
        });
    }
    ReflectAnalyzer.analyze = analyze;
    /* ---------------------------------------------------------
        CONTROLLER
    --------------------------------------------------------- */
    function _Analyze_controller(file, name, creator) {
        var _a;
        //----
        // VALIDATIONS
        //----
        // MUST BE TYPE OF A CREATOR WHO HAS THE CONSTRUCTOR
        if (!(creator instanceof Function &&
            creator.constructor instanceof Function))
            return null;
        // MUST HAVE THOSE MATADATA
        else if (ArrayUtil_1.ArrayUtil.has(Reflect.getMetadataKeys(creator), Constants.PATH_METADATA, Constants.HOST_METADATA, Constants.SCOPE_OPTIONS_METADATA) === false)
            return null;
        //----
        // CONSTRUCTION
        //----
        // BASIC INFO
        const paths = _Get_paths(Reflect.getMetadata(Constants.PATH_METADATA, creator));
        const meta = {
            file,
            name,
            paths,
            functions: [],
            security: _Get_securities(creator),
            swaggerTgas: (_a = Reflect.getMetadata("swagger/apiUseTags", creator)) !== null && _a !== void 0 ? _a : [],
        };
        // PARSE CHILDREN DATA
        for (const tuple of _Get_prototype_entries(creator)) {
            const child = _Analyze_function(creator.prototype, meta, ...tuple);
            if (child !== null)
                meta.functions.push(child);
        }
        // RETURNS
        return meta;
    }
    function _Get_prototype_entries(creator) {
        const keyList = Object.getOwnPropertyNames(creator.prototype);
        const entries = keyList.map((key) => [
            key,
            creator.prototype[key],
        ]);
        const parent = Object.getPrototypeOf(creator);
        if (parent.prototype !== undefined)
            entries.push(..._Get_prototype_entries(parent));
        return entries;
    }
    function _Get_paths(value) {
        if (typeof value === "string")
            return [value];
        else if (value.length === 0)
            return [""];
        else
            return value;
    }
    function _Get_securities(value) {
        const entire = Reflect.getMetadata("swagger/apiSecurity", value);
        return entire ? SecurityAnalyzer_1.SecurityAnalyzer.merge(...entire) : [];
    }
    function _Get_exceptions(value) {
        const entire = Reflect.getMetadata("nestia/TypedException", value);
        return Object.fromEntries((entire !== null && entire !== void 0 ? entire : []).map((exp) => [exp.status, exp]));
    }
    /* ---------------------------------------------------------
        FUNCTION
    --------------------------------------------------------- */
    function _Analyze_function(classProto, controller, name, proto) {
        var _a, _b, _c, _d, _e, _f, _g;
        //----
        // VALIDATIONS
        //----
        // MUST BE TYPE OF A FUNCTION
        if (!(proto instanceof Function))
            return null;
        // MUST HAVE THOSE METADATE
        else if (ArrayUtil_1.ArrayUtil.has(Reflect.getMetadataKeys(proto), Constants.PATH_METADATA, Constants.METHOD_METADATA) === false)
            return null;
        //----
        // CONSTRUCTION
        //----
        // BASIC INFO
        const encrypted = ((_c = (_b = (_a = Reflect.getMetadata(Constants.INTERCEPTORS_METADATA, proto)) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.constructor) === null || _c === void 0 ? void 0 : _c.name) === "EncryptedRouteInterceptor";
        const method = METHODS[Reflect.getMetadata(Constants.METHOD_METADATA, proto)];
        if (method === undefined || method === "OPTIONS")
            return null;
        const parameters = (() => {
            const nestParameters = Reflect.getMetadata(Constants.ROUTE_ARGS_METADATA, classProto.constructor, name);
            if (nestParameters === undefined)
                return [];
            const output = [];
            for (const tuple of Object.entries(nestParameters)) {
                const child = _Analyze_parameter(...tuple);
                if (child !== null)
                    output.push(child);
            }
            return output.sort((x, y) => x.index - y.index);
        })();
        // VALIDATE BODY
        const body = parameters.find((param) => param.category === "body");
        if (body !== undefined && (method === "GET" || method === "HEAD"))
            throw new Error(`Error on ${controller.name}.${name}(): "body" parameter cannot be used in the "GET" or "HEAD" method`);
        // DO CONSTRUCT
        const meta = {
            name,
            method: method === "ALL" ? "POST" : method,
            paths: _Get_paths(Reflect.getMetadata(Constants.PATH_METADATA, proto)),
            parameters,
            status: Reflect.getMetadata(Constants.HTTP_CODE_METADATA, proto),
            encrypted,
            contentType: encrypted
                ? "text/plain"
                : (_f = (_e = (_d = Reflect.getMetadata(Constants.HEADERS_METADATA, proto)) === null || _d === void 0 ? void 0 : _d.find((h) => typeof (h === null || h === void 0 ? void 0 : h.name) === "string" &&
                    typeof (h === null || h === void 0 ? void 0 : h.value) === "string" &&
                    h.name.toLowerCase() === "content-type")) === null || _e === void 0 ? void 0 : _e.value) !== null && _f !== void 0 ? _f : "application/json",
            security: _Get_securities(proto),
            exceptions: _Get_exceptions(proto),
            swaggerTags: [
                ...new Set([
                    ...controller.swaggerTgas,
                    ...((_g = Reflect.getMetadata("swagger/apiUseTags", proto)) !== null && _g !== void 0 ? _g : []),
                ]),
            ],
        };
        // VALIDATE PATH ARGUMENTS
        for (const controllerLocation of controller.paths)
            for (const metaLocation of meta.paths) {
                // NORMALIZE LOCATION
                const location = PathAnalyzer_1.PathAnalyzer.join(controllerLocation, metaLocation);
                // LIST UP PARAMETERS
                const binded = PathAnalyzer_1.PathAnalyzer.parameters(location, () => `${controller.name}.${name}()`).sort();
                const parameters = meta.parameters
                    .filter((param) => param.category === "param")
                    .map((param) => param.field)
                    .sort();
                // DO VALIDATE
                if ((0, module_1.equal)(binded, parameters) === false)
                    throw new Error(`Error on ${controller.name}.${name}(): binded arguments in the "path" between function's decorator and parameters' decorators are different (function: [${binded.join(", ")}], parameters: [${parameters.join(", ")}])`);
            }
        // RETURNS
        return meta;
    }
    /* ---------------------------------------------------------
        PARAMETER
    --------------------------------------------------------- */
    function _Analyze_parameter(key, param) {
        const symbol = key.split(":")[0];
        if (symbol.indexOf("__custom") !== -1)
            return _Analyze_custom_parameter(param);
        const typeIndex = Number(symbol[0]);
        if (isNaN(typeIndex) === true)
            return null;
        const type = NEST_PARAMETER_TYPES[typeIndex];
        if (type === undefined)
            return null;
        return {
            custom: false,
            name: key,
            category: type,
            index: param.index,
            field: param.data,
        };
    }
    function _Analyze_custom_parameter(param) {
        if (param.factory === undefined)
            return null;
        else if (param.factory.name === "TypedBody" ||
            param.factory.name === "EncryptedBody" ||
            param.factory.name === "PlainBody")
            return {
                custom: true,
                category: "body",
                index: param.index,
                name: param.name,
                field: param.data,
                encrypted: param.factory.name === "EncryptedBody",
                contentType: param.factory.name === "PlainBody" ||
                    param.factory.name === "EncryptedBody"
                    ? "text/plain"
                    : "application/json",
            };
        else if (param.factory.name === "TypedHeaders")
            return {
                custom: true,
                category: "headers",
                name: param.name,
                index: param.index,
                field: param.data,
            };
        else if (param.factory.name === "TypedParam")
            return {
                custom: true,
                category: "param",
                name: param.name,
                index: param.index,
                field: param.data,
            };
        else if (param.factory.name === "TypedQuery")
            return {
                custom: true,
                name: param.name,
                category: "query",
                index: param.index,
                field: undefined,
            };
        else
            return null;
    }
})(ReflectAnalyzer || (exports.ReflectAnalyzer = ReflectAnalyzer = {}));
// node_modules/@nestjs/common/lib/enums/request-method.enum.ts
const METHODS = [
    "GET",
    "POST",
    "PUT",
    "DELETE",
    "PATCH",
    "ALL",
    "OPTIONS",
    "HEAD",
];
// node_modules/@nestjs/common/lib/route-paramtypes.enum.ts
const NEST_PARAMETER_TYPES = [
    undefined,
    undefined,
    undefined,
    "body",
    "query",
    "param",
    "headers",
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
];
//# sourceMappingURL=ReflectAnalyzer.js.map