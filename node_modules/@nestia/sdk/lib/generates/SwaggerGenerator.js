"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwaggerGenerator = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const path_2 = __importDefault(require("path"));
const Singleton_1 = require("tstl/thread/Singleton");
const typia_1 = __importDefault(require("typia"));
const MetadataCollection_1 = require("typia/lib/factories/MetadataCollection");
const JsonApplicationProgrammer_1 = require("typia/lib/programmers/json/JsonApplicationProgrammer");
const FileRetriever_1 = require("../utils/FileRetriever");
const MapUtil_1 = require("../utils/MapUtil");
const SwaggerSchemaGenerator_1 = require("./internal/SwaggerSchemaGenerator");
var SwaggerGenerator;
(function (SwaggerGenerator) {
    SwaggerGenerator.generate = (checker) => (config) => (routeList) => __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d;
        console.log("Generating Swagger Documents");
        // VALIDATE SECURITY
        validate_security(config)(routeList);
        // PREPARE ASSETS
        const parsed = path_1.default.parse(config.output);
        const directory = path_1.default.dirname(parsed.dir);
        if (fs_1.default.existsSync(directory) === false)
            try {
                yield fs_1.default.promises.mkdir(directory);
            }
            catch (_e) { }
        if (fs_1.default.existsSync(directory) === false)
            throw new Error(`Error on NestiaApplication.swagger(): failed to create output directory: ${directory}`);
        const location = !!parsed.ext
            ? path_1.default.resolve(config.output)
            : path_1.default.join(path_1.default.resolve(config.output), "swagger.json");
        const collection = new MetadataCollection_1.MetadataCollection({
            replace: MetadataCollection_1.MetadataCollection.replace,
        });
        // CONSTRUCT SWAGGER DOCUMENTS
        const errors = [];
        const lazySchemas = [];
        const lazyProperties = [];
        const swagger = yield initialize(config);
        const pathDict = new Map();
        for (const route of routeList) {
            if (route.jsDocTags.find((tag) => tag.name === "internal"))
                continue;
            const path = MapUtil_1.MapUtil.take(pathDict, get_path(route.path, route.parameters), () => ({}));
            path[route.method.toLowerCase()] = generate_route({
                config,
                checker,
                collection,
                lazySchemas,
                lazyProperties,
                errors,
            })(route);
        }
        swagger.paths = {};
        for (const [path, routes] of pathDict)
            swagger.paths[path] = routes;
        // FILL JSON-SCHEMAS
        const application = JsonApplicationProgrammer_1.JsonApplicationProgrammer.write({
            purpose: "swagger",
        })(lazySchemas.map(({ metadata }) => metadata));
        swagger.components = Object.assign(Object.assign({}, ((_a = swagger.components) !== null && _a !== void 0 ? _a : {})), ((_b = application.components) !== null && _b !== void 0 ? _b : {}));
        lazySchemas.forEach(({ schema }, index) => {
            Object.assign(schema, application.schemas[index]);
        });
        for (const p of lazyProperties)
            Object.assign(p.schema, (_d = (_c = application.components.schemas) === null || _c === void 0 ? void 0 : _c[p.object]) === null || _d === void 0 ? void 0 : _d.properties[p.property]);
        // CONFIGURE SECURITY
        if (config.security)
            fill_security(config.security, swagger);
        // REPORT ERRORS
        if (errors.length) {
            for (const e of errors)
                console.error(`${path_2.default.relative(e.route.location, process.cwd())}:${e.route.symbol.class}.${e.route.symbol.function}:${e.from} - error TS(@nestia/sdk): invalid type detected.\n\n` +
                    e.messages.map((m) => `  - ${m}`).join("\n"), "\n\n");
            throw new TypeError("Invalid type detected");
        }
        // DO GENERATE
        yield fs_1.default.promises.writeFile(location, JSON.stringify(swagger, null, 2), "utf8");
    });
    const validate_security = (config) => (routeList) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const securityMap = new Map();
        for (const [key, value] of Object.entries((_a = config.security) !== null && _a !== void 0 ? _a : {}))
            securityMap.set(key, {
                scheme: emend_security(value),
                scopes: value.type === "oauth2"
                    ? new Set([
                        ...Object.keys((_c = (_b = value.flows.authorizationCode) === null || _b === void 0 ? void 0 : _b.scopes) !== null && _c !== void 0 ? _c : {}),
                        ...Object.keys((_e = (_d = value.flows.implicit) === null || _d === void 0 ? void 0 : _d.scopes) !== null && _e !== void 0 ? _e : {}),
                        ...Object.keys((_g = (_f = value.flows.password) === null || _f === void 0 ? void 0 : _f.scopes) !== null && _g !== void 0 ? _g : {}),
                        ...Object.keys((_j = (_h = value.flows.clientCredentials) === null || _h === void 0 ? void 0 : _h.scopes) !== null && _j !== void 0 ? _j : {}),
                    ])
                    : new Set(),
            });
        const validate = (reporter) => (key, scopes) => {
            const security = securityMap.get(key);
            if (security === undefined)
                return reporter(`target security scheme "${key}" does not exists.`);
            else if (scopes.length === 0)
                return;
            else if (security.scheme.type !== "oauth2")
                return reporter(`target security scheme "${key}" is not "oauth2" type, but you've configured the scopes.`);
            for (const s of scopes)
                if (security.scopes.has(s) === false)
                    reporter(`target security scheme "${key}" does not have a specific scope "${s}".`);
        };
        const violations = [];
        for (const route of routeList)
            for (const record of route.security)
                for (const [key, scopes] of Object.entries(record))
                    validate((str) => violations.push(`  - ${str} (${route.symbol} at "${route.location}")`))(key, scopes);
        if (violations.length)
            throw new Error(`Error on NestiaApplication.swagger(): invalid security specification. Check your "nestia.config.ts" file's "swagger.security" property, or each controller methods.\n` +
                `\n` +
                `List of violations:\n` +
                violations.join("\n"));
    };
    /* ---------------------------------------------------------
        INITIALIZERS
    --------------------------------------------------------- */
    const initialize = (config) => __awaiter(this, void 0, void 0, function* () {
        var _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
        const pack = new Singleton_1.Singleton(() => __awaiter(this, void 0, void 0, function* () {
            const location = yield FileRetriever_1.FileRetriever.file("package.json")(process.cwd());
            if (location === null)
                return null;
            try {
                const content = yield fs_1.default.promises.readFile(location, "utf8");
                const data = (input => { const assert = input => {
                    const __is = input => {
                        const $io0 = input => (undefined === input.name || "string" === typeof input.name) && (undefined === input.version || "string" === typeof input.version) && (undefined === input.description || "string" === typeof input.description) && (null !== input.license && (undefined === input.license || "string" === typeof input.license || "object" === typeof input.license && null !== input.license && $io1(input.license)));
                        const $io1 = input => "string" === typeof input.type && ("string" === typeof input.url && /^[a-zA-Z0-9]+:\/\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(input.url));
                        return "object" === typeof input && null !== input && false === Array.isArray(input) && $io0(input);
                    };
                    if (false === __is(input))
                        ((input, _path, _exceptionable = true) => {
                            const $guard = typia_1.default.json.assertParse.guard;
                            const $ao0 = (input, _path, _exceptionable = true) => (undefined === input.name || "string" === typeof input.name || $guard(_exceptionable, {
                                path: _path + ".name",
                                expected: "(string | undefined)",
                                value: input.name
                            })) && (undefined === input.version || "string" === typeof input.version || $guard(_exceptionable, {
                                path: _path + ".version",
                                expected: "(string | undefined)",
                                value: input.version
                            })) && (undefined === input.description || "string" === typeof input.description || $guard(_exceptionable, {
                                path: _path + ".description",
                                expected: "(string | undefined)",
                                value: input.description
                            })) && ((null !== input.license || $guard(_exceptionable, {
                                path: _path + ".license",
                                expected: "(__type.o1 | string | undefined)",
                                value: input.license
                            })) && (undefined === input.license || "string" === typeof input.license || ("object" === typeof input.license && null !== input.license || $guard(_exceptionable, {
                                path: _path + ".license",
                                expected: "(__type.o1 | string | undefined)",
                                value: input.license
                            })) && $ao1(input.license, _path + ".license", true && _exceptionable) || $guard(_exceptionable, {
                                path: _path + ".license",
                                expected: "(__type.o1 | string | undefined)",
                                value: input.license
                            })));
                            const $ao1 = (input, _path, _exceptionable = true) => ("string" === typeof input.type || $guard(_exceptionable, {
                                path: _path + ".type",
                                expected: "string",
                                value: input.type
                            })) && ("string" === typeof input.url && (/^[a-zA-Z0-9]+:\/\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(input.url) || $guard(_exceptionable, {
                                path: _path + ".url",
                                expected: "string & Format<\"url\">",
                                value: input.url
                            })) || $guard(_exceptionable, {
                                path: _path + ".url",
                                expected: "(string & Format<\"url\">)",
                                value: input.url
                            }));
                            return ("object" === typeof input && null !== input && false === Array.isArray(input) || $guard(true, {
                                path: _path + "",
                                expected: "__type",
                                value: input
                            })) && $ao0(input, _path + "", true) || $guard(true, {
                                path: _path + "",
                                expected: "__type",
                                value: input
                            });
                        })(input, "$input", true);
                    return input;
                }; input = JSON.parse(input); return assert(input); })(content);
                return {
                    title: data.name,
                    version: data.version,
                    description: data.description,
                    license: data.license
                        ? typeof data.license === "string"
                            ? { name: data.license }
                            : typeof data.license === "object"
                                ? {
                                    name: data.license.type,
                                    url: data.license.url,
                                }
                                : undefined
                        : undefined,
                };
            }
            catch (_y) {
                return null;
            }
        }));
        return {
            openapi: "3.0.1",
            servers: (_f = config.servers) !== null && _f !== void 0 ? _f : [
                {
                    url: "https://github.com/samchon/nestia",
                    description: "insert your server url",
                },
            ],
            info: Object.assign(Object.assign({}, ((_g = config.info) !== null && _g !== void 0 ? _g : {})), { version: (_l = (_j = (_h = config.info) === null || _h === void 0 ? void 0 : _h.version) !== null && _j !== void 0 ? _j : (_k = (yield pack.get())) === null || _k === void 0 ? void 0 : _k.version) !== null && _l !== void 0 ? _l : "0.1.0", title: (_q = (_o = (_m = config.info) === null || _m === void 0 ? void 0 : _m.title) !== null && _o !== void 0 ? _o : (_p = (yield pack.get())) === null || _p === void 0 ? void 0 : _p.title) !== null && _q !== void 0 ? _q : "Swagger Documents", description: (_u = (_s = (_r = config.info) === null || _r === void 0 ? void 0 : _r.description) !== null && _s !== void 0 ? _s : (_t = (yield pack.get())) === null || _t === void 0 ? void 0 : _t.description) !== null && _u !== void 0 ? _u : "Generated by nestia - https://github.com/samchon/nestia", license: (_w = (_v = config.info) === null || _v === void 0 ? void 0 : _v.license) !== null && _w !== void 0 ? _w : (_x = (yield pack.get())) === null || _x === void 0 ? void 0 : _x.license }),
            paths: {},
            components: {},
        };
    });
    function get_path(path, parameters) {
        const filtered = parameters.filter((param) => param.category === "param" && !!param.field);
        for (const param of filtered)
            path = path.replace(`:${param.field}`, `{${param.field}}`);
        return path;
    }
    const generate_route = (props) => (route) => {
        var _a, _b, _c, _d;
        const body = route.parameters.find((param) => param.category === "body");
        const getJsDocTexts = (name) => route.jsDocTags
            .filter((tag) => tag.name === name &&
            tag.text &&
            tag.text.find((elem) => elem.kind === "text" && elem.text.length) !== undefined)
            .map((tag) => tag.text.find((elem) => elem.kind === "text")
            .text);
        const description = ((_a = route.description) === null || _a === void 0 ? void 0 : _a.length)
            ? route.description
            : undefined;
        const summary = (() => {
            if (description === undefined)
                return undefined;
            const [explicit] = getJsDocTexts("summary");
            if (explicit === null || explicit === void 0 ? void 0 : explicit.length)
                return explicit;
            const index = description.indexOf(".");
            if (index <= 0)
                return undefined;
            const content = description.substring(0, index).trim();
            return content.length ? content : undefined;
        })();
        const deprecated = route.jsDocTags.find((tag) => tag.name === "deprecated");
        return {
            deprecated: deprecated ? true : undefined,
            tags: [
                ...route.swaggerTags,
                ...new Set([...getJsDocTexts("tag")]),
            ],
            operationId: (_b = route.operationId) !== null && _b !== void 0 ? _b : (_d = (_c = props.config).operationId) === null || _d === void 0 ? void 0 : _d.call(_c, {
                class: route.symbol.class,
                function: route.symbol.function,
                method: route.method,
                path: route.path,
            }),
            parameters: route.parameters
                .filter((param) => param.category !== "body")
                .map((param) => SwaggerSchemaGenerator_1.SwaggerSchemaGenerator.parameter(props)(route)(param))
                .flat(),
            requestBody: body
                ? SwaggerSchemaGenerator_1.SwaggerSchemaGenerator.body(props)(route)(body)
                : undefined,
            responses: SwaggerSchemaGenerator_1.SwaggerSchemaGenerator.response(props)(route),
            summary,
            description,
            security: route.security.length ? route.security : undefined,
            "x-nestia-namespace": [
                ...route.path
                    .split("/")
                    .filter((str) => str.length && str[0] !== ":"),
                route.name,
            ].join("."),
            "x-nestia-jsDocTags": route.jsDocTags,
            "x-nestia-method": route.method,
        };
    };
    function fill_security(security, swagger) {
        swagger.components.securitySchemes = {};
        for (const [key, value] of Object.entries(security))
            swagger.components.securitySchemes[key] = emend_security(value);
    }
    function emend_security(input) {
        var _a, _b;
        if (input.type === "apiKey")
            return Object.assign(Object.assign({}, input), { in: (_a = input.in) !== null && _a !== void 0 ? _a : "header", name: (_b = input.name) !== null && _b !== void 0 ? _b : "Authorization" });
        return input;
    }
})(SwaggerGenerator || (exports.SwaggerGenerator = SwaggerGenerator = {}));
//# sourceMappingURL=SwaggerGenerator.js.map