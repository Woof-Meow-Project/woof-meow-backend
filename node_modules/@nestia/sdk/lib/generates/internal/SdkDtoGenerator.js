"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdkDtoGenerator = void 0;
const fs_1 = __importDefault(require("fs"));
const MetadataCollection_1 = require("typia/lib/factories/MetadataCollection");
const MetadataFactory_1 = require("typia/lib/factories/MetadataFactory");
const Escaper_1 = require("typia/lib/utils/Escaper");
const ImportDictionary_1 = require("../../utils/ImportDictionary");
const MapUtil_1 = require("../../utils/MapUtil");
var SdkDtoGenerator;
(function (SdkDtoGenerator) {
    SdkDtoGenerator.generate = (checker) => (config) => (routes) => __awaiter(this, void 0, void 0, function* () {
        try {
            yield fs_1.default.promises.mkdir(`${config.output}/structures`);
        }
        catch (_a) { }
        const collection = new MetadataCollection_1.MetadataCollection({
            replace: MetadataCollection_1.MetadataCollection.replace,
        });
        for (const r of routes) {
            for (const p of r.parameters) {
                const res = MetadataFactory_1.MetadataFactory.analyze(checker)({
                    escape: false,
                    constant: true,
                    absorb: false,
                })(collection)(p.type);
                if (res.success)
                    p.metadata = res.data;
            }
            for (const e of Object.values(r.exceptions)) {
                const res = MetadataFactory_1.MetadataFactory.analyze(checker)({
                    escape: true,
                    constant: true,
                    absorb: false,
                })(collection)(e.type);
                if (res.success)
                    e.metadata = res.data;
            }
            const res = MetadataFactory_1.MetadataFactory.analyze(checker)({
                escape: true,
                constant: true,
                absorb: false,
            })(collection)(r.output.type);
            if (res.success)
                r.output.metadata = res.data;
        }
        const modules = new Map();
        for (const alias of collection.aliases())
            prepare(modules)(alias.name)((importer) => defineAlias(config)(importer)(alias));
        for (const object of collection.objects())
            prepare(modules)(object.name)((importer) => defineObject(config)(importer)(object));
        for (const module of modules.values())
            yield generateFile(config)(module);
    });
    const prepare = (dict) => (name) => (programmer) => {
        const accessors = name.split(".");
        let module;
        accessors.forEach((acc, i) => {
            module = MapUtil_1.MapUtil.take(dict, acc, () => ({
                name: accessors.slice(0, i + 1).join("."),
                children: new Map(),
            }));
            if (i === accessors.length - 1)
                module.programmer = programmer;
            dict = module.children;
        });
        return module;
    };
    const generateFile = (config) => (module) => __awaiter(this, void 0, void 0, function* () {
        const importer = new ImportDictionary_1.ImportDictionary(`${config.output}/structures/${module.name}.ts`);
        const body = writeModule(importer)(module);
        const content = [];
        if (!importer.empty())
            content.push(importer.toScript(`${config.output}/structures`), "");
        content.push(body);
        yield fs_1.default.promises.writeFile(importer.file, content.join("\n"), "utf8");
    });
    const writeModule = (importer) => (module) => {
        const content = [];
        if (module.programmer)
            content.push(module.programmer(importer));
        if (module.children.size) {
            content.push(`export namespace ${module.name.split(".").at(-1)} {`);
            for (const child of module.children.values())
                content.push(writeModule(importer)(child)
                    .split("\n")
                    .map((l) => `    ${l}`)
                    .join("\n"));
            content.push("}");
        }
        return content.join("\n");
    };
    const defineAlias = (config) => (importer) => (alias) => [
        ...writeComment(alias.value.atomics)(alias.description, alias.jsDocTags),
        `export type ${alias.name.split(".").at(-1)} = ${SdkDtoGenerator.decode(config)(importer)(alias.value)};`,
    ].join("\n");
    const defineObject = (config) => (importer) => (object) => {
        var _a;
        const top = [
            ...writeComment([])((_a = object.description) !== null && _a !== void 0 ? _a : null, object.jsDocTags),
            `export type ${object.name.split(".").at(-1)} = `,
        ].join("\n");
        if (object.properties.length === 0)
            return top + "{};";
        const regular = object.properties.filter((p) => p.key.isSoleLiteral());
        const dynamic = object.properties.filter((p) => !p.key.isSoleLiteral());
        const brackets = [];
        if (regular.length) {
            const row = ["{"];
            for (const p of regular) {
                const key = p.key.constants[0].values[0];
                const identifier = Escaper_1.Escaper.variable(key)
                    ? key
                    : JSON.stringify(key);
                row.push(...writeComment(p.value.atomics)(p.description, p.jsDocTags).map((l) => `    ${l}`), `    ${identifier}${p.value.isRequired() === false ? "?" : ""}: ${SdkDtoGenerator.decode(config)(importer)(p.value)};`);
            }
            row.push("}");
            brackets.push(row);
        }
        for (const p of dynamic) {
            const row = ["{"];
            row.push(...writeComment(p.value.atomics)(p.description, p.jsDocTags).map((l) => `    ${l}`), `    [key: ${SdkDtoGenerator.decode(config)(importer)(p.key)}]: ${SdkDtoGenerator.decode(config)(importer)(p.value)};`);
            row.push("}");
            brackets.push(row);
        }
        return top + brackets.map((row) => row.join("\n")).join(" & ");
    };
    const writeComment = (atomics) => (description, jsDocTags) => {
        const lines = [];
        if (description === null || description === void 0 ? void 0 : description.length)
            lines.push(...description.split("\n").map((s) => `${s}`));
        const filtered = !!atomics.length && !!(jsDocTags === null || jsDocTags === void 0 ? void 0 : jsDocTags.length)
            ? jsDocTags.filter((tag) => !atomics.some((a) => a.tags.some((r) => r.some((t) => t.kind === tag.name))))
            : jsDocTags !== null && jsDocTags !== void 0 ? jsDocTags : [];
        if ((description === null || description === void 0 ? void 0 : description.length) && filtered.length)
            lines.push("");
        if (filtered.length)
            lines.push(...filtered.map((t) => {
                var _a;
                return ((_a = t.text) === null || _a === void 0 ? void 0 : _a.length)
                    ? `@${t.name} ${t.text.map((e) => e.text).join("")}`
                    : `@${t.name}`;
            }));
        if (lines.length === 0)
            return [];
        return ["/**", ...lines.map((s) => ` * ${s}`), " */"];
    };
    SdkDtoGenerator.decode = (config) => (importer) => (meta, parentEscaped = false) => {
        const union = [];
        // COALESCES
        if (meta.any)
            union.push("any");
        if (meta.nullable)
            union.push("null");
        if (meta.isRequired() === false)
            union.push("undefined");
        if (parentEscaped === false && meta.escaped)
            union.push(decodeEscaped(config)(importer)(meta.escaped));
        // ATOMICS
        for (const atomic of meta.atomics)
            union.push(decodeAtomic(importer)(atomic));
        for (const constant of meta.constants)
            union.push(decodeConstant(constant));
        for (const tpl of meta.templates)
            union.push(decodeTemplate(config)(importer)(tpl));
        // ARRAYS
        for (const array of meta.arrays)
            union.push(decodeArray(config)(importer)(array));
        for (const tuple of meta.tuples)
            union.push(decodeTuple(config)(importer)(tuple));
        // OBJECTS
        for (const obj of meta.objects)
            union.push(decodeObject(config)(importer)(obj));
        for (const alias of meta.aliases)
            union.push(decodeAlias(config)(importer)(alias));
        // NATIVES
        for (const native of meta.natives)
            union.push(native);
        for (const set of meta.sets)
            union.push(`Set<${SdkDtoGenerator.decode(config)(importer)(set)}>`);
        for (const map of meta.maps)
            union.push(`Map<${SdkDtoGenerator.decode(config)(importer)(map.key)}, ${SdkDtoGenerator.decode(config)(importer)(map.value)}>`);
        return union.join(" | ");
    };
    const decodeEscaped = (config) => (importer) => (escaped) => {
        if (escaped.original.size() === 1 &&
            escaped.original.natives.length === 1 &&
            escaped.original.natives[0] === "Date")
            return `(string & ${importer.external({
                type: true,
                library: `typia/lib/tags/Format`,
                instance: "Format",
            })}<"date-time">)`;
        return `(${SdkDtoGenerator.decode(config)(importer)(escaped.returns, true)})`;
    };
    const decodeTypeTag = (importer) => (tag) => {
        const front = tag.name.split("<")[0];
        if (NATIVE_TYPE_TAGS.has(front)) {
            importer.external({
                type: true,
                library: `typia/lib/tags/${front}`,
                instance: front,
            });
            return tag.name;
        }
        importer.external({
            type: true,
            library: `typia/lib/tags/TagBase`,
            instance: "TagBase",
        });
        return `TagBase<${JSON.stringify(tag)}>`;
    };
    const decodeTypeTagMatrix = (importer) => (base, tags) => {
        if (tags.length === 0)
            return base;
        else if (tags.length === 1)
            return `(${base} & ${tags[0]
                .map((t) => decodeTypeTag(importer)(t))
                .join(" & ")})`;
        return ("(" +
            [
                base,
                ...tags.map((row) => `(${row
                    .map((t) => decodeTypeTag(importer)(t))
                    .join(" & ")})`),
            ] +
            ")");
    };
    const decodeAtomic = (importer) => (atomic) => decodeTypeTagMatrix(importer)(atomic.type, atomic.tags);
    const decodeTemplate = (config) => (importer) => (template) => "`" +
        template
            .map((meta) => meta.size() === 1 &&
            meta.isRequired() &&
            meta.nullable === false &&
            meta.constants.length === 1
            ? String(meta.constants[0].values[0])
                .split("`")
                .join("\\`")
            : `\${${SdkDtoGenerator.decode(config)(importer)(meta)}}`)
            .join("") +
        "`";
    const decodeConstant = (constant) => {
        if (constant.values.length === 0)
            return JSON.stringify(constant.values[0]);
        return `(${constant.values
            .map((val) => JSON.stringify(val))
            .join(" | ")})`;
    };
    const decodeArray = (config) => (importer) => (array) => decodeTypeTagMatrix(importer)(`Array<${SdkDtoGenerator.decode(config)(importer)(array.type.value)}>`, array.tags);
    const decodeTuple = (config) => (importer) => (tuple) => "[" +
        tuple.type.elements.map((e) => e.rest
            ? `...${SdkDtoGenerator.decode(config)(importer)(e.rest)}[]`
            : SdkDtoGenerator.decode(config)(importer)(e)) +
        "]";
    const decodeAlias = (config) => (importer) => (alias) => {
        importInternalFile(config)(importer)(alias.name);
        return alias.name;
    };
    const decodeObject = (config) => (importer) => (object) => {
        importInternalFile(config)(importer)(object.name);
        return object.name;
    };
    const importInternalFile = (config) => (importer) => (name) => {
        const top = name.split(".")[0];
        if (importer.file === `${config.output}/structures/${top}.ts`)
            return;
        importer.internal({
            type: true,
            file: `${config.output}/structures/${name.split(".")[0]}`,
            instance: top,
        });
    };
})(SdkDtoGenerator || (exports.SdkDtoGenerator = SdkDtoGenerator = {}));
const NATIVE_TYPE_TAGS = new Set([
    "ExclusiveMinimum",
    "ExclusiveMaximum",
    "Format",
    "Maximum",
    "MaxItems",
    "MaxLength",
    "Minimum",
    "MinItems",
    "MinLength",
    "MultipleOf",
    "Pattern",
    "Type",
]);
//# sourceMappingURL=SdkDtoGenerator.js.map