"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdkFunctionProgrammer = void 0;
const Pair_1 = require("tstl/utility/Pair");
const Escaper_1 = require("typia/lib/utils/Escaper");
const SdkDtoGenerator_1 = require("./SdkDtoGenerator");
const SdkImportWizard_1 = require("./SdkImportWizard");
const SdkSimulationProgrammer_1 = require("./SdkSimulationProgrammer");
const SdkTypeDefiner_1 = require("./SdkTypeDefiner");
var SdkFunctionProgrammer;
(function (SdkFunctionProgrammer) {
    SdkFunctionProgrammer.generate = (config) => (importer) => (route) => {
        const [x, y, z] = [head, body, tail].map((closure) => closure(config)(importer)(route)({
            headers: route.parameters.find((param) => param.category === "headers" &&
                param.field === undefined),
            query: route.parameters.find((param) => param.category === "query" &&
                param.field === undefined),
            input: route.parameters.find((param) => param.category === "body"),
        }));
        return `${x} ${y}\n${z}`;
    };
    /* ---------------------------------------------------------
        BODY
    --------------------------------------------------------- */
    const body = (config) => (importer) => (route) => (props) => {
        var _a;
        const encrypted = route.encrypted === true ||
            (props.input !== undefined &&
                props.input.custom === true &&
                props.input.category === "body" &&
                props.input.encrypted === true);
        // FETCH ARGUMENTS WITH REQUST BODY
        const parameters = filter_path_parameters(route)(props.query);
        const contentType = props.input !== undefined
            ? props.input.encrypted
                ? "text/plain"
                : (_a = props.input
                    .contentType) !== null && _a !== void 0 ? _a : "application/json"
            : undefined;
        const fetchArguments = [
            contentType
                ? [
                    "{",
                    "    ...connection,",
                    "    headers: {",
                    "        ...(connection.headers ?? {}),",
                    `        "Content-Type": "${contentType}",`,
                    "    },",
                    "}",
                ]
                : "connection",
            [
                "{",
                `    ...${route.name}.METADATA,`,
                `    path: ${route.name}.path(${parameters
                    .map((p) => p.name)
                    .join(", ")}),`,
                "} as const",
            ],
        ];
        if (props.input !== undefined) {
            fetchArguments.push(props.input.name);
            if (config.json === true)
                fetchArguments.push(`${route.name}.stringify`);
        }
        const assertions = config.assert === true &&
            route.parameters.filter((p) => p.category !== "headers" || p.field === undefined).length !== 0
            ? route.parameters
                .filter((p) => p.category !== "headers" ||
                p.field === undefined)
                .map((param) => `    ${SdkImportWizard_1.SdkImportWizard.typia(importer)}.assert<typeof ${param.name}>(${param.name});`)
                .join("\n") + "\n\n"
            : "";
        // FUNCTION CALL STATEMENT
        const caller = (awa) => {
            const random = () => [
                `${awa ? "await " : ""}${route.name}.simulate(`,
                `    connection,`,
                ...route.parameters
                    .filter((p) => p.category !== "headers")
                    .map((p) => `    ${p.name},`),
                `)`,
            ]
                .map((line, i) => i === 0 ? line : `${space(10)}${line}`)
                .join("\n");
            const fetch = (tab) => [
                `${awa ? "await " : ""}${SdkImportWizard_1.SdkImportWizard.Fetcher(encrypted)(importer)}.${config.propagate === true ? "propagate" : "fetch"}(`,
                fetchArguments
                    .map((param) => typeof param === "string"
                    ? `${tab}    ${param}`
                    : param
                        .map((str) => `${tab}    ${str}`)
                        .join("\n"))
                    .join(",\n") + ",",
                `${tab})`,
            ].join("\n");
            if (!config.simulate)
                return fetch(space(4));
            return (`!!connection.simulate\n` +
                `        ? ${random()}\n` +
                `        : ${fetch(space(10))}`);
        };
        if (route.setHeaders.length === 0)
            return `{\n${assertions}    return ${caller(false)};\n}`;
        // SET HEADERS
        const content = [
            `{\n`,
            assertions,
            `    const output: ${route.name}.Output = ${caller(true)};\n`,
            "\n",
            `    // configure header(s)\n`,
            `    connection.headers ??= {};\n`,
        ];
        const headerContents = (variable) => route.setHeaders.map((header) => {
            var _a;
            return header.type === "assigner"
                ? `Object.assign(connection.headers, ${access(variable)(header.source)});`
                : `${access("connection.headers")((_a = header.target) !== null && _a !== void 0 ? _a : header.source)} = ${access(variable)(header.source)};`;
        });
        if (config.propagate === true) {
            content.push(`    if (output.success) {\n`);
            content.push(...headerContents("output.data").map((line) => `        ${line}\n`));
            content.push(`    }\n`);
        }
        else
            content.push(...headerContents("output").map((line) => `    ${line}\n`));
        content.push("\n", "    return output;\n", "}");
        return content.join("");
    };
    const filter_path_parameters = (route) => (query) => {
        const parameters = route.parameters.filter((param) => param.category === "param" ||
            (param.category === "query" && param.field !== undefined));
        if (query)
            parameters.push(query);
        return parameters;
    };
    const access = (x) => (y) => y[0] === "[" ? `${x}${y}` : `${x}.${y}`;
    /* ---------------------------------------------------------
        HEAD & TAIL
    --------------------------------------------------------- */
    const head = (config) => (importer) => (route) => (props) => {
        var _a;
        //----
        // CONSTRUCT COMMENT
        //----
        // MAIN DESCRIPTION
        const comments = route.description
            ? route.description.split("\n")
            : [];
        // COMMENT TAGS
        const tags = route.jsDocTags.filter((tag) => tag.name !== "param" ||
            route.parameters
                .filter((p) => p.category !== "headers")
                .some((p) => { var _a, _b; return p.name === ((_b = (_a = tag.text) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.text); }));
        if (tags.length !== 0) {
            const content = tags.map((t) => {
                var _a;
                return ((_a = t.text) === null || _a === void 0 ? void 0 : _a.length)
                    ? `@${t.name} ${t.text.map((e) => e.text).join("")}`
                    : `@${t.name}`;
            });
            comments.push("", ...new Set(content));
        }
        // EXCEPTIONS
        for (const [key, value] of Object.entries(route.exceptions)) {
            if (comments.some((str) => str.startsWith(`@throw ${key}`) ||
                str.startsWith(`@throws ${key}`)))
                continue;
            comments.push(((_a = value.description) === null || _a === void 0 ? void 0 : _a.length)
                ? `@throws ${key} ${value.description.split("\n")[0]}`
                : `@throws ${key}`);
        }
        // POSTFIX
        if (!!comments.length)
            comments.push("");
        comments.push(`@controller ${route.symbol.class}.${route.symbol.function}`, `@path ${route.method} ${route.path}`, `@nestia Generated by Nestia - https://github.com/samchon/nestia`);
        //----
        // FINALIZATION
        //----
        // REFORM PARAMETERS TEXT
        const parameters = [
            route.parameters.some((p) => p.category === "headers" && p.field === undefined)
                ? `connection: ${SdkImportWizard_1.SdkImportWizard.IConnection(importer)}<${`${route.name}.Headers`}>`
                : `connection: ${SdkImportWizard_1.SdkImportWizard.IConnection(importer)}`,
            ...route.parameters
                .filter((p) => p.category !== "headers")
                .map((param) => {
                const type = config.primitive !== false &&
                    (param === props.query || param === props.input)
                    ? `${route.name}.${param === props.query ? "Query" : "Input"}`
                    : getTypeName(config)(importer)(param);
                return `${param.name}${param.optional ? "?" : ""}: ${type}`;
            }),
        ];
        // OUTPUT TYPE
        const output = config.propagate !== true && route.output.typeName === "void"
            ? "void"
            : `${route.name}.Output`;
        // RETURNS WITH CONSTRUCTION
        return ("" +
            "/**\n" +
            comments.map((str) => ` * ${str}`).join("\n") +
            "\n" +
            " */\n" +
            `export async function ${route.name}(\n` +
            parameters.map((str) => `    ${str},\n`).join("") +
            `): Promise<${output}>`);
    };
    const tail = (config) => (importer) => (route) => (props) => {
        var _a;
        // LIST UP TYPES
        const types = [];
        if (props.headers !== undefined)
            types.push(new Pair_1.Pair("Headers", SdkTypeDefiner_1.SdkTypeDefiner.headers(config)(importer)(props.headers)));
        if (props.query !== undefined)
            types.push(new Pair_1.Pair("Query", SdkTypeDefiner_1.SdkTypeDefiner.query(config)(importer)(props.query)));
        if (props.input !== undefined)
            types.push(new Pair_1.Pair("Input", SdkTypeDefiner_1.SdkTypeDefiner.input(config)(importer)(props.input)));
        if (config.propagate === true || route.output.typeName !== "void")
            types.push(new Pair_1.Pair("Output", SdkTypeDefiner_1.SdkTypeDefiner.output(config)(importer)(route)));
        // PATH WITH PARAMETERS
        const parameters = filter_path_parameters(route)(props.query);
        const path = compute_path({
            path: route.path,
            query: props.query,
            parameters,
        });
        return (`export namespace ${route.name} {\n` +
            (types.length !== 0
                ? types
                    .map((tuple) => `    export type ${tuple.first} = ${tuple.second};`)
                    .join("\n") + "\n"
                : "") +
            "\n" +
            [
                "export const METADATA = {",
                `    method: "${route.method}",`,
                `    path: "${route.path}",`,
                ...(props.input
                    ? [
                        `request: {`,
                        `    type: "${props.input
                            .encrypted
                            ? "text/plain"
                            : (_a = props.input.contentType) !== null && _a !== void 0 ? _a : "application/json"}",`,
                        `    encrypted: ${props.input.custom &&
                            props.input.category === "body" &&
                            props.input.encrypted}`,
                        `},`,
                    ].map((str) => `    ${str}`)
                    : ["    request: null,"]),
                ...(route.method !== "HEAD"
                    ? [
                        `response: {`,
                        `    type: "${route.output.contentType}",`,
                        `    encrypted: ${route.encrypted},`,
                        `},`,
                    ].map((str) => `    ${str}`)
                    : ["    response: null,"]),
                ...(route.status
                    ? [`    status: ${route.status},`]
                    : ["    status: null,"]),
                "} as const;",
            ]
                .map((line) => `    ${line}`)
                .join("\n") +
            "\n\n" +
            `    export const path = (${parameters
                .map((param) => {
                var _a;
                return `${param.name}: ${param.category === "query" &&
                    param.typeName === ((_a = props.query) === null || _a === void 0 ? void 0 : _a.typeName)
                    ? `${route.name}.Query`
                    : getTypeName(config)(importer)(param)}`;
            })
                .join(", ")}): string => {\n` +
            `${path};\n` +
            `    }\n` +
            (config.simulate === true && route.output.typeName !== "void"
                ? `    export const random = (g?: Partial<${SdkImportWizard_1.SdkImportWizard.typia(importer)}.IRandomGenerator>): ${SdkTypeDefiner_1.SdkTypeDefiner.responseBody(config)(importer)(route)} =>\n` +
                    `        ${SdkImportWizard_1.SdkImportWizard.typia(importer)}.random<${SdkTypeDefiner_1.SdkTypeDefiner.responseBody(config)(importer)(route)}>(g);\n`
                : "") +
            (config.simulate === true
                ? SdkSimulationProgrammer_1.SdkSimulationProgrammer.generate(config)(importer)(route) + "\n"
                : "") +
            (config.json === true &&
                route.parameters.find((param) => param.category === "body") !==
                    undefined
                ? `    export const stringify = (input: Input) => ${SdkImportWizard_1.SdkImportWizard.typia(importer)}.json.assertStringify(input);\n`
                : "") +
            "}");
    };
    const compute_path = (props) => {
        for (const param of props.parameters)
            if (param.category === "param")
                props.path = props.path.replace(`:${param.field}`, `\${encodeURIComponent(${param.name} ?? "null")}`);
        // NO QUERY PARAMETER
        const queryParams = props.parameters.filter((param) => param.category === "query" && param.field !== undefined);
        if (props.query === undefined && queryParams.length === 0)
            return `${space(8)}return \`${props.path}\``;
        const computeName = (str) => props.parameters
            .filter((p) => p.category !== "headers")
            .find((p) => p.name === str) !== undefined
            ? computeName("_" + str)
            : str;
        const variables = computeName("variables");
        const search = computeName("search");
        const encoded = computeName("encoded");
        const wrapper = (expr) => [
            `const ${variables}: Record<any, any> = ${expr};`,
            `const ${search}: URLSearchParams = new URLSearchParams();`,
            `for (const [key, value] of Object.entries(${variables}))`,
            `    if (value === undefined) continue;`,
            `    else if (Array.isArray(value))`,
            `        value.forEach((elem) => ${search}.append(key, String(elem)));`,
            `    else`,
            `        ${search}.set(key, String(value));`,
            `const ${encoded}: string = ${search}.toString();`,
            `return \`${props.path}\${${encoded}.length ? \`?\${${encoded}}\` : ""}\`;`,
        ]
            .map((str) => `${space(8)}${str}`)
            .join("\n");
        if (props.query !== undefined && queryParams.length === 0)
            return wrapper(`${props.query.name} as any`);
        else if (props.query === undefined)
            return wrapper(`
        {
            ${rest_query_parameters(queryParams)}
        } as any`);
        return wrapper(`
        {
            ...${props.query.name},
            ${rest_query_parameters(queryParams)},
        } as any`);
    };
    const rest_query_parameters = (parameters) => parameters
        .filter((param) => param.category !== "headers")
        .map((param) => param.name === param.field
        ? param.name
        : `${Escaper_1.Escaper.variable(param.field)
            ? param.field
            : JSON.stringify(param.field)}: ${param.name}`)
        .join(`,\n${space(12)}`);
})(SdkFunctionProgrammer || (exports.SdkFunctionProgrammer = SdkFunctionProgrammer = {}));
const space = (count) => " ".repeat(count);
const getTypeName = (config) => (importer) => (p) => p.metadata
    ? SdkDtoGenerator_1.SdkDtoGenerator.decode(config)(importer)(p.metadata)
    : p.typeName;
//# sourceMappingURL=SdkFunctionProgrammer.js.map