"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwaggerSchemaGenerator = void 0;
const tstl_1 = require("tstl");
const MetadataFactory_1 = require("typia/lib/factories/MetadataFactory");
const Metadata_1 = require("typia/lib/schemas/metadata/Metadata");
const SwaggerSchemaValidator_1 = require("./SwaggerSchemaValidator");
var SwaggerSchemaGenerator;
(function (SwaggerSchemaGenerator) {
    SwaggerSchemaGenerator.response = (props) => (route) => {
        var _a, _b, _c, _d;
        const output = {};
        //----
        // EXCEPTION STATUSES
        //----
        // FROM DECORATOR
        for (const [status, exp] of Object.entries(route.exceptions)) {
            const result = MetadataFactory_1.MetadataFactory.analyze(props.checker)({
                escape: true,
                constant: true,
                absorb: false,
                validate: (meta) => {
                    const bigint = meta.atomics.some((a) => a.type === "bigint") ||
                        meta.constants.some((a) => a.type === "bigint");
                    return bigint ? ["bigint type is not allowed."] : [];
                },
            })(props.collection)(exp.type);
            if (result.success === false)
                props.errors.push(...result.errors.map((e) => (Object.assign(Object.assign({}, e), { route, from: `response(status: ${status})` }))));
            output[status] = {
                description: (_a = exp.description) !== null && _a !== void 0 ? _a : "",
                content: {
                    "application/json": {
                        schema: coalesce(props)(result),
                    },
                },
            };
        }
        // FROM COMMENT TAGS -> ANY
        for (const tag of route.jsDocTags) {
            if (tag.name !== "throw" && tag.name !== "throws")
                continue;
            const text = (_c = (_b = tag.text) === null || _b === void 0 ? void 0 : _b.find((elem) => elem.kind === "text")) === null || _c === void 0 ? void 0 : _c.text;
            if (text === undefined)
                continue;
            const elements = text
                .split(" ")
                .map((str) => str.trim());
            const status = elements[0];
            if (isNaN(Number(status)) &&
                status !== "2XX" &&
                status !== "3XX" &&
                status !== "4XX" &&
                status !== "5XX")
                continue;
            const description = elements.length === 1
                ? undefined
                : elements.slice(1).join(" ");
            const oldbie = output[status];
            if (description && oldbie !== undefined)
                oldbie.description = description;
            else if (oldbie === undefined)
                output[status] = {
                    description: description !== null && description !== void 0 ? description : "",
                    content: {
                        "application/json": {
                            schema: {},
                        },
                    },
                };
        }
        //----
        // SUCCESS
        //----
        // STATUS
        const status = route.status !== undefined
            ? String(route.status)
            : route.method === "GET" ||
                route.method === "HEAD" ||
                route.method === "DELETE"
                ? "200"
                : "201";
        // SCHEMA
        const result = MetadataFactory_1.MetadataFactory.analyze(props.checker)({
            escape: true,
            constant: true,
            absorb: false,
            validate: (meta) => {
                const bigint = meta.atomics.some((a) => a.type === "bigint") ||
                    meta.constants.some((a) => a.type === "bigint");
                return bigint ? ["bigint type is not allowed."] : [];
            },
        })(props.collection)(route.output.type);
        if (result.success === false)
            props.errors.push(...result.errors.map((e) => (Object.assign(Object.assign({}, e), { route, from: "response" }))));
        // DO ASSIGN
        const description = (_d = describe(route, "return")) !== null && _d !== void 0 ? _d : describe(route, "returns");
        output[status] = {
            description: route.encrypted
                ? `${warning
                    .get(!!description)
                    .get("response", route.method)}${description !== null && description !== void 0 ? description : ""}`
                : description !== null && description !== void 0 ? description : "",
            content: route.output.typeName === "void"
                ? undefined
                : {
                    [route.output.contentType]: {
                        schema: coalesce(props)(result),
                    },
                },
            "x-nestia-encrypted": route.encrypted,
        };
        return output;
    };
    SwaggerSchemaGenerator.body = (props) => (route) => (param) => {
        // ANALZE TYPE WITH VALIDATION
        const result = MetadataFactory_1.MetadataFactory.analyze(props.checker)({
            escape: true,
            constant: true,
            absorb: true,
            validate: (meta) => {
                const bigint = meta.atomics.some((a) => a.type === "bigint") ||
                    meta.constants.some((a) => a.type === "bigint");
                return bigint ? ["bigint type is not allowed."] : [];
            },
        })(props.collection)(param.type);
        if (result.success === false)
            props.errors.push(...result.errors.map((e) => (Object.assign(Object.assign({}, e), { route, from: param.name }))));
        // LIST UP PROPERTIES
        const contentType = param.custom && param.category === "body"
            ? param.contentType
            : "application/json";
        const encrypted = param.custom && param.category === "body" && param.encrypted;
        const description = describe(route, "param", param.name);
        // RETURNS WITH LAZY CONSTRUCTION
        const schema = coalesce(props)(result);
        return {
            description: encrypted
                ? `${warning.get(!!description).get("request")}${description !== null && description !== void 0 ? description : ""}`
                : description,
            content: {
                [contentType]: {
                    schema,
                },
            },
            required: true,
            "x-nestia-encrypted": encrypted,
        };
    };
    SwaggerSchemaGenerator.parameter = (props) => (route) => (param) => param.category === "headers"
        ? headers(props)(route)(param)
        : param.category === "param"
            ? [path(props)(route)(param)]
            : query(props)(route)(param);
    const path = (props) => (route) => (param) => {
        // ANALZE TYPE WITH VALIDATION
        const result = MetadataFactory_1.MetadataFactory.analyze(props.checker)({
            escape: false,
            constant: true,
            absorb: true,
            validate: SwaggerSchemaValidator_1.SwaggerSchemaValidator.path,
        })(props.collection)(param.type);
        if (result.success === false)
            props.errors.push(...result.errors.map((e) => (Object.assign(Object.assign({}, e), { route, from: param.name }))));
        // RETURNS WITH LAZY CONSTRUCTION
        return lazy(props)(route)(param, result);
    };
    const headers = (props) => (route) => (param) => decomposible(props)(route)(param)(MetadataFactory_1.MetadataFactory.analyze(props.checker)({
        escape: false,
        constant: true,
        absorb: true,
        validate: param.custom
            ? SwaggerSchemaValidator_1.SwaggerSchemaValidator.headers
            : undefined,
    })(props.collection)(param.type));
    const query = (props) => (route) => (param) => decomposible(props)(route)(param)(MetadataFactory_1.MetadataFactory.analyze(props.checker)({
        escape: false,
        constant: true,
        absorb: true,
        validate: param.custom
            ? SwaggerSchemaValidator_1.SwaggerSchemaValidator.query
            : undefined,
    })(props.collection)(param.type));
    const decomposible = (props) => (route) => (param) => (result) => {
        const decoded = lazy(props)(route)(param, result);
        if (result.success === false) {
            props.errors.push(...result.errors.map((e) => (Object.assign(Object.assign({}, e), { route, from: param.name }))));
            return [decoded];
        }
        else if (props.config.decompose !== true ||
            result.data.objects.length === 0)
            return [decoded];
        return result.data.objects[0].properties
            .filter((p) => p.jsDocTags.every((tag) => tag.name !== "hidden"))
            .map((p) => {
            var _a;
            const schema = {};
            props.lazyProperties.push({
                schema,
                object: result.data.objects[0].name,
                property: p.key.constants[0].values[0],
            });
            return {
                name: p.key.constants[0].values[0],
                in: param.category === "headers"
                    ? "header"
                    : param.category,
                schema,
                description: (_a = p.description) !== null && _a !== void 0 ? _a : undefined,
                required: p.value.isRequired(),
            };
        });
    };
    const lazy = (props) => (route) => (param, result) => {
        var _a, _b;
        const schema = coalesce(props)(result);
        return {
            name: (_a = param.field) !== null && _a !== void 0 ? _a : param.name,
            in: param.category === "headers"
                ? "header"
                : param.category === "param"
                    ? "path"
                    : param.category,
            schema,
            description: (_b = describe(route, "param", param.name)) !== null && _b !== void 0 ? _b : "",
            required: result.success ? result.data.isRequired() : true,
        };
    };
    const coalesce = (props) => (result) => {
        const schema = {};
        props.lazySchemas.push({
            metadata: result.success ? result.data : any.get(),
            schema,
        });
        return schema;
    };
    const describe = (route, tagName, parameterName) => {
        var _a;
        const parametric = parameterName
            ? (tag) => tag.text.find((elem) => elem.kind === "parameterName" &&
                elem.text === parameterName) !== undefined
            : () => true;
        const tag = route.jsDocTags.find((tag) => tag.name === tagName && tag.text && parametric(tag));
        return tag && tag.text
            ? (_a = tag.text.find((elem) => elem.kind === "text")) === null || _a === void 0 ? void 0 : _a.text
            : undefined;
    };
})(SwaggerSchemaGenerator || (exports.SwaggerSchemaGenerator = SwaggerSchemaGenerator = {}));
const warning = new tstl_1.Singleton((described) => {
    return new tstl_1.Singleton((type, method) => {
        const summary = type === "request"
            ? "Request body must be encrypted."
            : "Response data have been encrypted.";
        const component = type === "request"
            ? "[EncryptedBody](https://github.com/samchon/@nestia/core#encryptedbody)"
            : `[EncryptedRoute.${method[0].toUpperCase()}.${method
                .substring(1)
                .toLowerCase()}](https://github.com/samchon/@nestia/core#encryptedroute)`;
        const content = [
            "## Warning",
            "",
            summary,
            "",
            `The ${type} body data would be encrypted as "AES-128(256) / CBC mode / PKCS#5 Padding / Base64 Encoding", through the ${component} component.`,
            "",
            `Therefore, just utilize this swagger editor only for referencing. If you need to call the real API, using [SDK](https://github.com/samchon/nestia#software-development-kit) would be much better.`,
        ];
        if (described === true)
            content.push("----------------", "");
        return content.join("\n");
    });
});
const any = new tstl_1.Singleton(() => Metadata_1.Metadata.from({
    any: true,
    required: true,
    optional: false,
    nullable: false,
    functional: false,
    atomics: [],
    constants: [],
    templates: [],
    escaped: null,
    rest: null,
    arrays: [],
    tuples: [],
    objects: [],
    aliases: [],
    natives: [],
    sets: [],
    maps: [],
}, {
    aliases: [],
    arrays: [],
    tuples: [],
    objects: [],
}));
//# sourceMappingURL=SwaggerSchemaGenerator.js.map