"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwaggerSchemaValidator = void 0;
const MetadataArray_1 = require("typia/lib/schemas/metadata/MetadataArray");
var SwaggerSchemaValidator;
(function (SwaggerSchemaValidator) {
    SwaggerSchemaValidator.path = (meta) => {
        const errors = [];
        const insert = (msg) => errors.push(msg);
        if (meta.any)
            insert("do not allow any type");
        if (meta.isRequired() === false)
            insert("do not allow undefindable type");
        const atomics = CoreMetadataUtil.atomics(meta);
        const expected = meta.atomics.length +
            meta.templates.length +
            meta.constants
                .map((c) => c.values.length)
                .reduce((a, b) => a + b, 0);
        if (meta.size() !== expected || atomics.size === 0)
            insert("only atomic or constant types are allowed");
        if (atomics.size > 1)
            insert("do not allow union type");
        return errors;
    };
    SwaggerSchemaValidator.query = (meta, explore) => {
        const errors = [];
        const insert = (msg) => errors.push(msg);
        if (explore.top === true) {
            // TOP MUST BE ONLY OBJECT
            if (meta.objects.length !== 1 || meta.bucket() !== 1)
                insert("only one object type is allowed.");
            if (meta.nullable === true)
                insert("query parameters cannot be null.");
            if (meta.isRequired() === false)
                insert("query parameters cannot be undefined.");
        }
        else if (explore.nested !== null &&
            explore.nested instanceof MetadataArray_1.MetadataArray) {
            const atomics = CoreMetadataUtil.atomics(meta);
            const expected = meta.atomics.length +
                meta.templates.length +
                meta.constants
                    .map((c) => c.values.length)
                    .reduce((a, b) => a + b, 0);
            if (atomics.size > 1)
                insert("union type is not allowed in array.");
            if (meta.nullable)
                insert("nullable type is not allowed in array.");
            if (meta.isRequired() === false)
                insert("optional type is not allowed in array.");
            if (meta.size() !== expected)
                insert("only atomic or constant types are allowed in array.");
        }
        else if (explore.object && explore.property !== null) {
            //----
            // COMMON
            //----
            // PROPERTY MUST BE SOLE
            if (typeof explore.property === "object")
                insert("dynamic property is not allowed.");
            // DO NOT ALLOW TUPLE TYPE
            if (meta.tuples.length)
                insert("tuple type is not allowed.");
            // DO NOT ALLOW UNION TYPE
            if (CoreMetadataUtil.isUnion(meta))
                insert("union type is not allowed.");
            // DO NOT ALLOW NESTED OBJECT
            if (meta.objects.length ||
                meta.sets.length ||
                meta.maps.length ||
                meta.natives.length)
                insert("nested object type is not allowed.");
            //----
            // ARRAY CASES
            //----
            const isArray = meta.arrays.length > 1 || meta.tuples.length > 1;
            // ARRAY TYPE MUST BE REQUIRED
            if (isArray && meta.isRequired() === false)
                insert("optional type is not allowed when array.");
            // SET-COOKIE MUST BE ARRAY
            if (explore.property === "set-cookie" && !isArray)
                insert("set-cookie property must be array.");
        }
        return errors;
    };
    SwaggerSchemaValidator.headers = (meta, explore) => {
        const errors = [];
        const insert = (msg) => errors.push(msg);
        if (explore.top === true) {
            // TOP MUST BE ONLY OBJECT
            if (meta.objects.length !== 1 || meta.bucket() !== 1)
                insert("only one object type is allowed.");
            if (meta.nullable === true)
                insert("headers cannot be null.");
            if (meta.isRequired() === false)
                insert("headers cannot be null.");
        }
        else if (explore.nested !== null &&
            explore.nested instanceof MetadataArray_1.MetadataArray) {
            const atomics = CoreMetadataUtil.atomics(meta);
            const expected = meta.atomics.length +
                meta.templates.length +
                meta.constants
                    .map((c) => c.values.length)
                    .reduce((a, b) => a + b, 0);
            if (atomics.size > 1)
                insert("union type is not allowed in array.");
            if (meta.nullable)
                insert("nullable type is not allowed in array.");
            if (meta.isRequired() === false)
                insert("optional type is not allowed.");
            if (meta.size() !== expected)
                insert("only atomic or constant types are allowed in array.");
        }
        else if (explore.object && explore.property !== null) {
            //----
            // COMMON
            //----
            // PROPERTY MUST BE SOLE
            if (typeof explore.property === "object")
                insert("dynamic property is not allowed.");
            // DO NOT ALLOW TUPLE TYPE
            if (meta.tuples.length)
                insert("tuple type is not allowed.");
            // DO NOT ALLOW UNION TYPE
            if (CoreMetadataUtil.isUnion(meta))
                insert("union type is not allowed.");
            // DO NOT ALLOW NESTED OBJECT
            if (meta.objects.length ||
                meta.sets.length ||
                meta.maps.length ||
                meta.natives.length)
                insert("nested object type is not allowed.");
            // DO NOT ALLOW NULLABLE
            if (meta.nullable)
                insert("nullable type is not allowed.");
            //----
            // ARRAY CASES
            //----
            const isArray = meta.arrays.length > 1;
            // ARRAY TYPE MUST BE REQUIRED
            if (isArray && meta.isRequired() === false)
                insert("optional type is not allowed when array.");
            // SET-COOKIE MUST BE ARRAY
            if (explore.property === "set-cookie" && !isArray)
                insert("set-cookie property must be array.");
            // MUST BE SINGULAR CASE
            if (typeof explore.property === "string" &&
                SINGULAR.has(explore.property) &&
                isArray)
                insert("property cannot be array.");
        }
        return errors;
    };
})(SwaggerSchemaValidator || (exports.SwaggerSchemaValidator = SwaggerSchemaValidator = {}));
var CoreMetadataUtil;
(function (CoreMetadataUtil) {
    CoreMetadataUtil.atomics = (meta) => new Set([
        ...meta.atomics.map((a) => a.type),
        ...meta.constants.map((c) => c.type),
        ...(meta.templates.length ? ["string"] : []),
    ]);
    CoreMetadataUtil.isUnion = (meta) => CoreMetadataUtil.atomics(meta).size +
        meta.arrays.length +
        meta.tuples.length +
        meta.natives.length +
        meta.maps.length +
        meta.objects.length >
        1;
})(CoreMetadataUtil || (CoreMetadataUtil = {}));
const SINGULAR = new Set([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "server",
    "user-agent",
]);
//# sourceMappingURL=SwaggerSchemaValidator.js.map