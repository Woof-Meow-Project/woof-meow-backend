"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportDictionary = void 0;
const path_1 = __importDefault(require("path"));
const HashMap_1 = require("tstl/container/HashMap");
const HashSet_1 = require("tstl/container/HashSet");
const Pair_1 = require("tstl/utility/Pair");
class ImportDictionary {
    constructor(file) {
        this.file = file;
        this.components_ = new HashMap_1.HashMap();
    }
    empty() {
        return this.components_.empty();
    }
    external(props) {
        var _a;
        const composition = this.components_.take(new Pair_1.Pair(props.library, props.type), () => ({
            location: `node_modules/${props.library}`,
            elements: new HashSet_1.HashSet(),
            default: false,
            type: props.type,
        }));
        if (props.instance === null)
            composition.default = true;
        else
            composition.elements.insert(props.instance);
        return (_a = props.instance) !== null && _a !== void 0 ? _a : props.library;
    }
    internal(props) {
        var _a;
        const file = (() => {
            if (props.file.substring(props.file.length - 5) === ".d.ts")
                return props.file.substring(0, props.file.length - 5);
            else if (props.file.substring(props.file.length - 3) === ".ts")
                return props.file.substring(0, props.file.length - 3);
            return props.file;
        })();
        const composition = this.components_.take(new Pair_1.Pair(file, props.type), () => ({
            location: file,
            elements: new HashSet_1.HashSet(),
            default: false,
            type: props.type,
        }));
        if (props.instance === null) {
            composition.default = true;
            if (props.name)
                composition.name = props.name;
        }
        else
            composition.elements.insert(props.instance);
        return (_a = props.instance) !== null && _a !== void 0 ? _a : file;
    }
    toScript(outDir) {
        const external = [];
        const internal = [];
        const locator = (str) => {
            const location = path_1.default
                .relative(outDir, str)
                .split("\\")
                .join("/");
            const index = location.lastIndexOf(NODE_MODULES);
            return index === -1
                ? location.startsWith("..")
                    ? location
                    : `./${location}`
                : location.substring(index + NODE_MODULES.length);
        };
        const enroll = (filter) => (container) => {
            var _a;
            const compositions = this.components_
                .toJSON()
                .filter((c) => filter(c.second.location))
                .map((e) => (Object.assign(Object.assign({}, e.second), { location: locator(e.second.location) })))
                .sort((a, b) => a.location.localeCompare(b.location));
            for (const c of compositions) {
                const brackets = [];
                if (c.default)
                    brackets.push((_a = c.name) !== null && _a !== void 0 ? _a : c.location);
                if (c.elements.empty() === false)
                    brackets.push(`{ ${c.elements
                        .toJSON()
                        .sort((a, b) => a.localeCompare(b))
                        .join(", ")} }`);
                container.push(`import ${c.type ? "type " : ""}${brackets.join(", ")} from "${c.location}";`);
            }
        };
        enroll((str) => str.indexOf(NODE_MODULES) !== -1)(external);
        enroll((str) => str.indexOf(NODE_MODULES) === -1)(internal);
        if (external.length && internal.length)
            external.push("");
        return [...external, ...internal].join("\n");
    }
}
exports.ImportDictionary = ImportDictionary;
const NODE_MODULES = "node_modules/";
//# sourceMappingURL=ImportDictionary.js.map