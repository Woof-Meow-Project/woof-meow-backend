"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.AcceptorBase = void 0;
/**
 * @packageDocumentation
 * @module tgrid.protocols
 */
//----------------------------------------------------------------
var Communicator_1 = require("../../components/Communicator");
var DomainError_1 = require("tstl/exception/DomainError");
var RuntimeError_1 = require("tstl/exception/RuntimeError");
/**
 * Basic Acceptor.
 *
 * The `AcceptorBase` is an abstract acceptor class, who can accept or reject connection from
 * a remote client in the server side. If the client's connection has been accepted, the
 * `AcceptorBase` can start interaction with the client through the
 * [RFC](https://github.com/samchon/tgrid#13-remote-function-call) (Remote Function Call).
 *
 * Also, when declaring this {@link AcceptorBase} type, you've to define two template arguments,
 * *Header* and *Provider*. The *Header* type repersents an initial data gotten from the remote
 * client after the connection. I hope you and client not to omit it and utilize it as an
 * activation tool to enhance security.
 *
 * The second template argument *Provider* represents the features provided for the remote client.
 * If you don't have any plan to provide any feature to the remote client, just declare it as
 * `null`.
 *
 * @template Header Type of the header containing initial data.
 * @template Provider Type of features provided for the remote system.
 * @author Jeongho Nam - https://github.com/samchon
 */
var AcceptorBase = /** @class */ (function (_super) {
    __extends(AcceptorBase, _super);
    /* ----------------------------------------------------------------
        ACCEPTIONS
    ---------------------------------------------------------------- */
    /**
     * @hidden
     */
    function AcceptorBase(header) {
        var _this = _super.call(this, undefined) || this;
        _this.header_ = header;
        _this.state_ = -1 /* AcceptorBase.State.NONE */;
        return _this;
    }
    Object.defineProperty(AcceptorBase.prototype, "header", {
        /* ----------------------------------------------------------------
            ACCESSORS
        ---------------------------------------------------------------- */
        /**
         * Header containing initialization data like activation.
         */
        get: function () {
            return this.header_;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AcceptorBase.prototype, "state", {
        /**
         * Get state.
         *
         * Get current state of connection state with the remote client.
         *
         * List of values are such like below:
         *
         *   - `REJECTING`: The `reject` method is on running.
         *   - `NONE`: This instance is newly created, but did nothing yet.
         *   - `ACCEPTING`: The `accept` method is on running.
         *   - `OPEN`: The connection is online.
         *   - `CLOSING`: The `close` method is on running.
         *   - `CLOSED`: The connection is offline.
         */
        get: function () {
            return this.state_;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @hidden
     */
    AcceptorBase.prototype.inspectReady = function (method) {
        // NO ERROR
        if (this.state_ === 1 /* AcceptorBase.State.OPEN */)
            return null;
        // ERROR, ONE OF THEM
        else if (this.state_ === -1 /* AcceptorBase.State.NONE */)
            return new DomainError_1.DomainError("Error on ".concat(this.constructor.name, ".").concat(method, "(): not accepted yet."));
        else if (this.state_ === 0 /* AcceptorBase.State.ACCEPTING */)
            return new DomainError_1.DomainError("Error on ".concat(this.constructor.name, ".").concat(method, "(): it's on accepting, wait for a second."));
        else if (this.state_ === -2 /* AcceptorBase.State.REJECTING */ ||
            2 /* AcceptorBase.State.CLOSING */)
            return new RuntimeError_1.RuntimeError("Error on ".concat(this.constructor.name, ".").concat(method, "(): the connection is on closing."));
        else if (this.state_ === 3 /* AcceptorBase.State.CLOSED */)
            return new RuntimeError_1.RuntimeError("Error on ".concat(this.constructor.name, ".").concat(method, "(): the connection has been closed."));
        // UNKNOWN ERROR, IT MAY NOT OCCURED
        else
            return new RuntimeError_1.RuntimeError("Error on ".concat(this.constructor.name, ".").concat(method, "(): unknown error, but not connected."));
    };
    return AcceptorBase;
}(Communicator_1.Communicator));
exports.AcceptorBase = AcceptorBase;
//# sourceMappingURL=AcceptorBase.js.map