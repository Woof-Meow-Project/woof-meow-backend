import { Invoke } from "../../components/Invoke";
import { ConnectorBase } from "../internal/ConnectorBase";
import { IWebCommunicator } from "./internal/IWebCommunicator";
/**
 * Web Socket Connector.
 *
 * The `WebConnector` is a communicator class who can connect to websocket server and
 * interact with it using RFC (Remote Function Call).
 *
 * You can connect to the websocket server using {@link connect}() method. The interaction
 * would be started if the server is opened by {@link WebServer.open}() and the server
 * accepts your connection by {@link WebAcceptor.accept}().
 *
 * Note that, after you business has been completed, please close the connection using
 * {@link close}() or let the server to {@link WebAcceptor.close close itself}. If you don't
 * close the connection in time, it may waste vulnerable resources of the server.
 *
 * Also, when declaring this {@link WebConnector} type, you've to define two template arguments,
 * *Header* and *Provider*. The *Header* type repersents an initial data gotten from the remote
 * client after the connection. I hope you and client not to omit it and utilize it as an
 * activation tool to enhance security.
 *
 * The second template argument *Provider* represents the features provided for the remote system.
 * If you don't have any plan to provide any feature to the remote system, just declare it as
 * `null`.
 *
 * @template Header Type of the header containing initial data.
 * @template Provider Type of features provided for the remote system.
 * @author Jeongho Nam - https://github.com/samchon
 */
export declare class WebConnector<Header, Provider extends object | null> extends ConnectorBase<Header, Provider> implements IWebCommunicator {
    /**
     * @hidden
     */
    private socket_?;
    /**
     * Connect to remote websocket server.
     *
     * Try connection to the remote websocket server with its address and waiting for the
     * server to accept the trial. If the server rejects your connection, then exception
     * would be thrown (in *Promise.catch*, as `WebError`).
     *
     * After the connection and your business has been completed, don't forget to closing the
     * connection in time to prevent waste of the server resource.
     *
     * @param url URL address to connect.
     * @param options Detailed options like timeout.
     */
    connect(url: string, options?: Partial<WebConnector.IConnectOptions>): Promise<void>;
    /**
     * @hidden
     */
    private _Wait_connection;
    /**
     * @inheritDoc
     */
    close(code?: number, reason?: string): Promise<void>;
    /**
     * @hidden
     */
    private _Handshake;
    /**
     * Connection URL.
     */
    get url(): string | undefined;
    /**
     * Get state.
     *
     * Get current state of connection state with the websocket server.
     *
     * List of values are such like below:
     *
     *   - `NONE`: The {@link WebConnector} instance is newly created, but did nothing yet.
     *   - `CONNECTING`: The {@link WebConnector.connect} method is on running.
     *   - `OPEN`: The connection is online.
     *   - `CLOSING`: The {@link WebConnector.close} method is on running.
     *   - `CLOSED`: The connection is offline.
     */
    get state(): WebConnector.State;
    /**
     * @hidden
     */
    protected sendData(invoke: Invoke): Promise<void>;
    /**
     * @hidden
     */
    private _Handle_message;
    /**
     * @hidden
     */
    private _Handle_close;
}
/**
 *
 */
export declare namespace WebConnector {
    /**
     * Current state of the {@link WebConnector}.
     */
    export import State = ConnectorBase.State;
    /**
     * Connection options for the {@link WebConnector.connect}.
     */
    interface IConnectOptions {
        /**
         * Milliseconds to wait the web-socket server to accept or reject it. If omitted, the waiting would be forever.
         */
        timeout: number;
    }
}
