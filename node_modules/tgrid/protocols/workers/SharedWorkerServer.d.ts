/**
 * @packageDocumentation
 * @module tgrid.protocols.workers
 */
import { IServer } from "../internal/IServer";
import { SharedWorkerAcceptor } from "./SharedWorkerAcceptor";
/**
 * SharedWorker server.
 *
 *  - available only in the Web Browser.
 *
 * The `SharedWorkerServer` is a class representing a server server in a `SharedWorker`
 * environment. Clients connecting to the `SharedWorkerServer` would communicate with this
 * server through {@link SharedWorkerAcceptor} objects using RFC (Remote Function Call).
 *
 * To open the server, use the {@link open}() method with a callback function which would be
 * called whenever a client has been connected. After your business, don't forget to closing
 * the connection using one of them below. If you don't close that, vulnerable memory usage
 * and communication channel would not be destroyed and it may cause the memory leak.
 *
 *  - {@link close}()
 *  - {@link SharedWorkerAcceptor.close}()
 *  - {@link SharedWorkerConnector.close}()
 *
 * Also, when declaring this {@link SharedWorkerServer} type, you've to define two template
 * arguments, *Header* and *Provider*. The *Header* type repersents an initial data gotten from the
 * remote client after the connection.
 *
 * The second template argument *Provider* represents the features provided for the remote client.
 * If you don't have any plan to provide any feature to the remote client, just declare it as
 * `null`.
 *
 * @template Header Type of the header containing initial data.
 * @template Provider Type of features provided for the remote system.
 * @author Jeongho Nam - https://github.com/samchon
 */
export declare class SharedWorkerServer<Header, Provider extends object | null> implements IServer<SharedWorkerServer.State> {
    /**
     * @hidden
     */
    private state_;
    /**
     * @hidden
     */
    private acceptors_;
    /**
     * Default Constructor.
     */
    constructor();
    /**
     * Open shared worker server.
     *
     * Open a server through the shared worker protocol, with *handler* function determining
     * whether to accept the client's connection or not. After the server has been opened, clients
     * can connect to that websocket server by using the {@link SharedWorkerServer} class.
     *
     * When implementing the *handler* function with the {@link SharedWorkerServer} instance, calls
     * the {@link SharedWorkerAcceptor.accept} method if you want to accept the new client's
     * connection. Otherwise you dont't want to accept the client and reject its connection, just
     * calls the {@link SharedWorkerAcceptor.reject} instead.
     *
     * @param handler Callback function called whenever client connects.
     */
    open(handler: (acceptor: SharedWorkerAcceptor<Header, Provider>) => Promise<void>): Promise<void>;
    /**
     * Close server.
     *
     * Close all connections between its remote clients ({@link SharedWorkerConnector}s).
     *
     * It destories all RFCs (remote function calls) between this server and remote clients
     * (through `Driver<Controller>`) that are not returned (completed) yet. The destruction
     * causes all incompleted RFCs to throw exceptions.
     */
    close(): Promise<void>;
    /**
     * @hidden
     */
    private _Handle_connect;
    /**
     * Get server state.
     *
     * Get current state of the websocket server.
     *
     * List of values are such like below:
     *
     *   - `NONE`: The `{@link SharedWorkerServer} instance is newly created, but did nothing yet.
     *   - `OPENING`: The {@link SharedWorkerServer.open} method is on running.
     *   - `OPEN`: The websocket server is online.
     *   - `CLOSING`: The {@link SharedWorkerServer.close} method is on running.
     *   - `CLOSED`: The websocket server is offline.
     */
    get state(): SharedWorkerServer.State;
}
/**
 *
 */
export declare namespace SharedWorkerServer {
    /**
     * Current state of the {@link SharedWorkerServer}.
     */
    export import State = IServer.State;
}
