import { Invoke } from "../../components/Invoke";
import { IWorkerSystem } from "./internal/IWorkerSystem";
import { ConnectorBase } from "../internal/ConnectorBase";
/**
 * Worker Connector.
 *
 * The `WorkerConnector` is a communicator class, who can create an `Worker` instance and
 * communicate with it using RFC (Remote Function Call), considering the `Worker` as a
 * remote system ({@link WorkerServer}).
 *
 * You can create an `Worker` instance with {@link compile}() or {@link connect}() method.
 * Anyway, after creation of the `Worker` instance, the `Worker` program must open a server
 * using the {@link WorkerServer.open}() method.
 *
 * Note that, after your business, don't forget terminating the worker using {@link close}()
 * or {@link WorkerServer.close}(). If you don't terminate it, then vulnerable memory and
 * communication channel would not be destroyed and it may cause the memory leak.
 *
 * Also, when declaring this {@link WorkerConnector} type, you've to define two template arguments,
 * *Header* and *Provider*. The *Header* type repersents an initial data gotten from the remote
 * system after the connection. I hope you and server not to omit it and utilize it as an
 * activation tool to enhance security.
 *
 * The second template argument *Provider* represents the features provided for the remote system.
 * If you don't have any plan to provide any feature to the remote system, just declare it as
 * `null`.
 *
 * @template Header Type of header containing initialization data like activation.
 * @template Provider Type of features provided for remote system.
 * @author Jeongho Nam - https://github.com/samchon
 */
export declare class WorkerConnector<Header, Provider extends object | null> extends ConnectorBase<Header, Provider> implements IWorkerSystem {
    private readonly compiler_;
    /**
     * @hidden
     */
    private worker_?;
    /**
     * Initializer Constructor.
     *
     * @param header An object containing initialization data like activation.
     * @param provider An object providing features for remote system.
     * @param type You can specify the worker mode when NodeJS. Default is "thread".
     */
    constructor(header: Header, provider: Provider, type?: "thread" | "process");
    /**
     * Compile server and connect to there.
     *
     * The {@link compile} method tries compile JS source code, creates `Worker` instance
     * with that code connects to the `Worker`. To complete the compilation and connection,
     * the `Worker` program must open that server using the {@link WorkerServer.open}()
     * method.
     *
     * Note that, after your business has been completed, you've to close the `Worker` using
     * {@link close}() or {@link WorkerServer.close}(). If you don't close that, vulnerable
     * memory usage and communication channel would not be destroyed and it may cause the
     * memory leak.
     *
     * @param content JS Source code to compile.
     * @param timeout Detailed options like timeout.
     */
    compile(content: string, options?: Partial<WorkerConnector.IConnectOptions>): Promise<void>;
    /**
     * Connect to server.
     *
     * The {@link connect}() method tries to create an `Worker` instance and connect to the
     * `Worker`. To complete the connection, the `Worker` program must open that server using
     * the {@link WorkerServer.open}() method.
     *
     * Note that, after your business has been completed, you've to close the `Worker` using
     * {@link close}() or {@link WorkerServer.close}(). If you don't close that, vulnerable
     * memory usage and communication channel would not be destroyed and it may cause the
     * memory leak.
     *
     * @param jsFile JS File to be {@link WorkerServer}.
     * @param args Headers containing initialization data like activation.
     * @param timeout Detailed options like timeout.
     */
    connect(jsFile: string, options?: Partial<WorkerConnector.IConnectOptions>): Promise<void>;
    /**
     * @hidden
     */
    private _Test_connection;
    /**
     * @hidden
     */
    private _Connect;
    /**
     * @hidden
     */
    private _Handshake;
    /**
     * @inheritDoc
     */
    close(): Promise<void>;
    /**
     * @hidden
     */
    protected sendData(invoke: Invoke): Promise<void>;
    /**
     * @hidden
     */
    private _Handle_message;
    /**
     * @hidden
     */
    private _Handle_close;
}
/**
 *
 */
export declare namespace WorkerConnector {
    /**
     * Current state of the {@link WorkerConnector}.
     */
    export import State = ConnectorBase.State;
    /**
     * Connection options for the {@link WorkerConnector.connect}.
     */
    interface IConnectOptions {
        /**
         * Milliseconds to wait the worker server to accept or reject it. If omitted, the waiting would be forever.
         */
        timeout: number;
        /**
         * Arguments only for the NodeJS environments.
         */
        execArgv: string[];
    }
}
