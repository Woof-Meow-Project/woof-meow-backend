"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonMetadataFactory = void 0;
var TransformerError_1 = require("../transformers/TransformerError");
var MetadataCollection_1 = require("./MetadataCollection");
var MetadataFactory_1 = require("./MetadataFactory");
var JsonMetadataFactory;
(function (JsonMetadataFactory) {
    JsonMetadataFactory.analyze = function (method) {
        return function (checker) {
            return function (type) {
                var collection = new MetadataCollection_1.MetadataCollection();
                var result = MetadataFactory_1.MetadataFactory.analyze(checker)({
                    escape: true,
                    constant: true,
                    absorb: true,
                    validate: JsonMetadataFactory.validate,
                })(collection)(type);
                if (result.success === false)
                    throw TransformerError_1.TransformerError.from(method)(result.errors);
                return [collection, result.data];
            };
        };
    };
    JsonMetadataFactory.validate = function (meta) {
        var output = [];
        if (meta.atomics.some(function (a) { return a.type === "bigint"; }) ||
            meta.constants.some(function (c) { return c.type === "bigint"; }))
            output.push("JSON does not support bigint type.");
        if (meta.tuples.some(function (t) {
            return t.type.elements.some(function (e) { return e.isRequired() === false; });
        }) ||
            meta.arrays.some(function (a) { return a.type.value.isRequired() === false; }))
            output.push("JSON does not support undefined type in array.");
        return output;
    };
})(JsonMetadataFactory || (exports.JsonMetadataFactory = JsonMetadataFactory = {}));
//# sourceMappingURL=JsonMetadataFactory.js.map